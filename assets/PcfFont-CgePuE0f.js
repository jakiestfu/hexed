import{k as O}from"./index-DZ3xxA7Z.js";var w=Object.getOwnPropertyNames,v=(d,h)=>function(){return h||(0,d[w(d)[0]])((h={exports:{}}).exports,h),h.exports},B=v({"<stdin>"(d){(function(h,o){typeof define=="function"&&define.amd?define(["exports","kaitai-struct/KaitaiStream","./BytesWithIo"],o):typeof d=="object"&&d!==null&&typeof d.nodeType!="number"?o(d,O.KaitaiStream,require("./BytesWithIo")):o(h.PcfFont||(h.PcfFont={}),h.KaitaiStream,h.BytesWithIo||(h.BytesWithIo={}))})(typeof self<"u"?self:d,function(h,o,g){var y=(function(){a.Types=Object.freeze({PROPERTIES:1,ACCELERATORS:2,METRICS:4,BITMAPS:8,INK_METRICS:16,BDF_ENCODINGS:32,SWIDTHS:64,GLYPH_NAMES:128,BDF_ACCELERATORS:256,1:"PROPERTIES",2:"ACCELERATORS",4:"METRICS",8:"BITMAPS",16:"INK_METRICS",32:"BDF_ENCODINGS",64:"SWIDTHS",128:"GLYPH_NAMES",256:"BDF_ACCELERATORS"});function a(r,_,p){this._io=r,this._parent=_,this._root=p||this,this._debug={},this._read()}a.prototype._read=function(){if(this._debug.magic={start:this._io.pos,ioOffset:this._io.byteOffset},this.magic=this._io.readBytes(4),this._debug.magic.end=this._io.pos,o.byteArrayCompare(this.magic,new Uint8Array([1,102,99,112]))!=0){var r=new o.ValidationNotEqualError(new Uint8Array([1,102,99,112]),this.magic,this._io,"/seq/0");throw this._debug.magic.validationError=r,r}this._debug.numTables={start:this._io.pos,ioOffset:this._io.byteOffset},this.numTables=this._io.readU4le(),this._debug.numTables.end=this._io.pos,this._debug.tables={start:this._io.pos,ioOffset:this._io.byteOffset},this._debug.tables.arr=[],this.tables=[];for(var _=0;_<this.numTables;_++)this._debug.tables.arr[_]={start:this._io.pos,ioOffset:this._io.byteOffset},this.tables.push(new l(this._io,this,this._root)),this._debug.tables.arr[_].end=this._io.pos;this._debug.tables.end=this._io.pos};var f=a.Format=(function(){function r(_,p,u){this._io=_,this._parent=p,this._root=u,this._debug={},this._read()}return r.prototype._read=function(){this._debug.padding1={start:this._io.pos,ioOffset:this._io.byteOffset},this.padding1=this._io.readBitsIntBe(2),this._debug.padding1.end=this._io.pos,this._debug.scanUnitMask={start:this._io.pos,ioOffset:this._io.byteOffset},this.scanUnitMask=this._io.readBitsIntBe(2),this._debug.scanUnitMask.end=this._io.pos,this._debug.isMostSignificantBitFirst={start:this._io.pos,ioOffset:this._io.byteOffset},this.isMostSignificantBitFirst=this._io.readBitsIntBe(1)!=0,this._debug.isMostSignificantBitFirst.end=this._io.pos,this._debug.isBigEndian={start:this._io.pos,ioOffset:this._io.byteOffset},this.isBigEndian=this._io.readBitsIntBe(1)!=0,this._debug.isBigEndian.end=this._io.pos,this._debug.glyphPadMask={start:this._io.pos,ioOffset:this._io.byteOffset},this.glyphPadMask=this._io.readBitsIntBe(2),this._debug.glyphPadMask.end=this._io.pos,this._io.alignToByte(),this._debug.format={start:this._io.pos,ioOffset:this._io.byteOffset},this.format=this._io.readU1(),this._debug.format.end=this._io.pos,this._debug.padding={start:this._io.pos,ioOffset:this._io.byteOffset},this.padding=this._io.readU2le(),this._debug.padding.end=this._io.pos},r})(),l=a.Table=(function(){function r(e,t,i){this._io=e,this._parent=t,this._root=i,this._debug={},this._read()}r.prototype._read=function(){this._debug.type={start:this._io.pos,ioOffset:this._io.byteOffset,enumName:"PcfFont.Types"},this.type=this._io.readU4le(),this._debug.type.end=this._io.pos,this._debug.format={start:this._io.pos,ioOffset:this._io.byteOffset},this.format=new f(this._io,this,this._root),this._debug.format.end=this._io.pos,this._debug.lenBody={start:this._io.pos,ioOffset:this._io.byteOffset},this.lenBody=this._io.readU4le(),this._debug.lenBody.end=this._io.pos,this._debug.ofsBody={start:this._io.pos,ioOffset:this._io.byteOffset},this.ofsBody=this._io.readU4le(),this._debug.ofsBody.end=this._io.pos};var _=r.BdfEncodings=(function(){function e(t,i,s){this._io=t,this._parent=i,this._root=s,this._debug={},this._read()}return e.prototype._read=function(){this._debug.format={start:this._io.pos,ioOffset:this._io.byteOffset},this.format=new f(this._io,this,this._root),this._debug.format.end=this._io.pos,this._debug.minCharOrByte2={start:this._io.pos,ioOffset:this._io.byteOffset},this.minCharOrByte2=this._io.readU2le(),this._debug.minCharOrByte2.end=this._io.pos,this._debug.maxCharOrByte2={start:this._io.pos,ioOffset:this._io.byteOffset},this.maxCharOrByte2=this._io.readU2le(),this._debug.maxCharOrByte2.end=this._io.pos,this._debug.minByte1={start:this._io.pos,ioOffset:this._io.byteOffset},this.minByte1=this._io.readU2le(),this._debug.minByte1.end=this._io.pos,this._debug.maxByte1={start:this._io.pos,ioOffset:this._io.byteOffset},this.maxByte1=this._io.readU2le(),this._debug.maxByte1.end=this._io.pos,this._debug.defaultChar={start:this._io.pos,ioOffset:this._io.byteOffset},this.defaultChar=this._io.readU2le(),this._debug.defaultChar.end=this._io.pos,this._debug.glyphIndexes={start:this._io.pos,ioOffset:this._io.byteOffset},this._debug.glyphIndexes.arr=[],this.glyphIndexes=[];for(var t=0;t<(this.maxCharOrByte2-this.minCharOrByte2+1)*(this.maxByte1-this.minByte1+1);t++)this._debug.glyphIndexes.arr[t]={start:this._io.pos,ioOffset:this._io.byteOffset},this.glyphIndexes.push(this._io.readU2le()),this._debug.glyphIndexes.arr[t].end=this._io.pos;this._debug.glyphIndexes.end=this._io.pos},e})(),p=r.Bitmaps=(function(){function e(t,i,s){this._io=t,this._parent=i,this._root=s,this._debug={},this._read()}return e.prototype._read=function(){this._debug.format={start:this._io.pos,ioOffset:this._io.byteOffset},this.format=new f(this._io,this,this._root),this._debug.format.end=this._io.pos,this._debug.numGlyphs={start:this._io.pos,ioOffset:this._io.byteOffset},this.numGlyphs=this._io.readU4le(),this._debug.numGlyphs.end=this._io.pos,this._debug.offsets={start:this._io.pos,ioOffset:this._io.byteOffset},this._debug.offsets.arr=[],this.offsets=[];for(var t=0;t<this.numGlyphs;t++)this._debug.offsets.arr[t]={start:this._io.pos,ioOffset:this._io.byteOffset},this.offsets.push(this._io.readU4le()),this._debug.offsets.arr[t].end=this._io.pos;this._debug.offsets.end=this._io.pos,this._debug.bitmapSizes={start:this._io.pos,ioOffset:this._io.byteOffset},this._debug.bitmapSizes.arr=[],this.bitmapSizes=[];for(var t=0;t<4;t++)this._debug.bitmapSizes.arr[t]={start:this._io.pos,ioOffset:this._io.byteOffset},this.bitmapSizes.push(this._io.readU4le()),this._debug.bitmapSizes.arr[t].end=this._io.pos;this._debug.bitmapSizes.end=this._io.pos},e})(),u=r.GlyphNames=(function(){function e(i,s,n){this._io=i,this._parent=s,this._root=n,this._debug={},this._read()}e.prototype._read=function(){this._debug.format={start:this._io.pos,ioOffset:this._io.byteOffset},this.format=new f(this._io,this,this._root),this._debug.format.end=this._io.pos,this._debug.numGlyphs={start:this._io.pos,ioOffset:this._io.byteOffset},this.numGlyphs=this._io.readU4le(),this._debug.numGlyphs.end=this._io.pos,this._debug.names={start:this._io.pos,ioOffset:this._io.byteOffset},this._debug.names.arr=[],this.names=[];for(var i=0;i<this.numGlyphs;i++)this._debug.names.arr[i]={start:this._io.pos,ioOffset:this._io.byteOffset},this.names.push(new t(this._io,this,this._root)),this._debug.names.arr[i].end=this._io.pos;this._debug.names.end=this._io.pos,this._debug.lenStrings={start:this._io.pos,ioOffset:this._io.byteOffset},this.lenStrings=this._io.readU4le(),this._debug.lenStrings.end=this._io.pos,this._debug.strings={start:this._io.pos,ioOffset:this._io.byteOffset},this._raw_strings=this._io.readBytes(this.lenStrings);var s=new o(this._raw_strings);this.strings=new g.BytesWithIo(s,null,null),this._debug.strings.end=this._io.pos};var t=e.StringRef=(function(){function i(s,n,b){this._io=s,this._parent=n,this._root=b,this._debug={},this._read()}return i.prototype._read=function(){this._debug.ofsString={start:this._io.pos,ioOffset:this._io.byteOffset},this.ofsString=this._io.readU4le(),this._debug.ofsString.end=this._io.pos},Object.defineProperty(i.prototype,"value",{get:function(){if(this._m_value!==void 0)return this._m_value;var s=this._parent.strings._io,n=s.pos;return s.seek(this.ofsString),this._debug._m_value={start:s.pos,ioOffset:s.byteOffset},this._m_value=o.bytesToStr(s.readBytesTerm(0,!1,!0,!0),"UTF-8"),this._debug._m_value.end=s.pos,s.seek(n),this._m_value}}),i})();return e})(),m=r.Properties=(function(){function e(i,s,n){this._io=i,this._parent=s,this._root=n,this._debug={},this._read()}e.prototype._read=function(){this._debug.format={start:this._io.pos,ioOffset:this._io.byteOffset},this.format=new f(this._io,this,this._root),this._debug.format.end=this._io.pos,this._debug.numProps={start:this._io.pos,ioOffset:this._io.byteOffset},this.numProps=this._io.readU4le(),this._debug.numProps.end=this._io.pos,this._debug.props={start:this._io.pos,ioOffset:this._io.byteOffset},this._debug.props.arr=[],this.props=[];for(var i=0;i<this.numProps;i++)this._debug.props.arr[i]={start:this._io.pos,ioOffset:this._io.byteOffset},this.props.push(new t(this._io,this,this._root)),this._debug.props.arr[i].end=this._io.pos;this._debug.props.end=this._io.pos,this._debug.padding={start:this._io.pos,ioOffset:this._io.byteOffset},this.padding=this._io.readBytes((this.numProps&3)==0?0:4-(this.numProps&3)),this._debug.padding.end=this._io.pos,this._debug.lenStrings={start:this._io.pos,ioOffset:this._io.byteOffset},this.lenStrings=this._io.readU4le(),this._debug.lenStrings.end=this._io.pos,this._debug.strings={start:this._io.pos,ioOffset:this._io.byteOffset},this._raw_strings=this._io.readBytes(this.lenStrings);var s=new o(this._raw_strings);this.strings=new g.BytesWithIo(s,null,null),this._debug.strings.end=this._io.pos};var t=e.Prop=(function(){function i(s,n,b){this._io=s,this._parent=n,this._root=b,this._debug={},this._read()}return i.prototype._read=function(){this._debug.ofsName={start:this._io.pos,ioOffset:this._io.byteOffset},this.ofsName=this._io.readU4le(),this._debug.ofsName.end=this._io.pos,this._debug.isString={start:this._io.pos,ioOffset:this._io.byteOffset},this.isString=this._io.readU1(),this._debug.isString.end=this._io.pos,this._debug.valueOrOfsValue={start:this._io.pos,ioOffset:this._io.byteOffset},this.valueOrOfsValue=this._io.readU4le(),this._debug.valueOrOfsValue.end=this._io.pos},Object.defineProperty(i.prototype,"intValue",{get:function(){return this._m_intValue!==void 0?this._m_intValue:(this.isString==0&&(this._debug._m_intValue={},this._m_intValue=this.valueOrOfsValue),this._m_intValue)}}),Object.defineProperty(i.prototype,"name",{get:function(){if(this._m_name!==void 0)return this._m_name;var s=this._parent.strings._io,n=s.pos;return s.seek(this.ofsName),this._debug._m_name={start:s.pos,ioOffset:s.byteOffset},this._m_name=o.bytesToStr(s.readBytesTerm(0,!1,!0,!0),"UTF-8"),this._debug._m_name.end=s.pos,s.seek(n),this._m_name}}),Object.defineProperty(i.prototype,"strValue",{get:function(){if(this._m_strValue!==void 0)return this._m_strValue;if(this.isString!=0){var s=this._parent.strings._io,n=s.pos;s.seek(this.valueOrOfsValue),this._debug._m_strValue={start:s.pos,ioOffset:s.byteOffset},this._m_strValue=o.bytesToStr(s.readBytesTerm(0,!1,!0,!0),"UTF-8"),this._debug._m_strValue.end=s.pos,s.seek(n)}return this._m_strValue}}),i})();return e})(),c=r.Swidths=(function(){function e(t,i,s){this._io=t,this._parent=i,this._root=s,this._debug={},this._read()}return e.prototype._read=function(){this._debug.format={start:this._io.pos,ioOffset:this._io.byteOffset},this.format=new f(this._io,this,this._root),this._debug.format.end=this._io.pos,this._debug.numGlyphs={start:this._io.pos,ioOffset:this._io.byteOffset},this.numGlyphs=this._io.readU4le(),this._debug.numGlyphs.end=this._io.pos,this._debug.swidths={start:this._io.pos,ioOffset:this._io.byteOffset},this._debug.swidths.arr=[],this.swidths=[];for(var t=0;t<this.numGlyphs;t++)this._debug.swidths.arr[t]={start:this._io.pos,ioOffset:this._io.byteOffset},this.swidths.push(this._io.readU4le()),this._debug.swidths.arr[t].end=this._io.pos;this._debug.swidths.end=this._io.pos},e})();return Object.defineProperty(r.prototype,"body",{get:function(){if(this._m_body!==void 0)return this._m_body;var e=this._io.pos;switch(this._io.seek(this.ofsBody),this._debug._m_body={start:this._io.pos,ioOffset:this._io.byteOffset},this.type){case a.Types.BDF_ENCODINGS:this._raw__m_body=this._io.readBytes(this.lenBody);var t=new o(this._raw__m_body);this._m_body=new _(t,this,this._root);break;case a.Types.BITMAPS:this._raw__m_body=this._io.readBytes(this.lenBody);var t=new o(this._raw__m_body);this._m_body=new p(t,this,this._root);break;case a.Types.GLYPH_NAMES:this._raw__m_body=this._io.readBytes(this.lenBody);var t=new o(this._raw__m_body);this._m_body=new u(t,this,this._root);break;case a.Types.PROPERTIES:this._raw__m_body=this._io.readBytes(this.lenBody);var t=new o(this._raw__m_body);this._m_body=new m(t,this,this._root);break;case a.Types.SWIDTHS:this._raw__m_body=this._io.readBytes(this.lenBody);var t=new o(this._raw__m_body);this._m_body=new c(t,this,this._root);break;default:this._m_body=this._io.readBytes(this.lenBody);break}return this._debug._m_body.end=this._io.pos,this._io.seek(e),this._m_body}}),r})();return a})();h.PcfFont=y})}});const P=B(),T={id:"pcf_font",title:"Portable Compiled Format (PCF) font",ksy:{meta:{id:"pcf_font",title:"Portable Compiled Format (PCF) font","file-extension":"pcf",xref:{justsolve:"PCF",wikidata:"Q3398726"},license:"CC0-1.0","ks-version":.9,imports:["/common/bytes_with_io"],encoding:"UTF-8",endian:"le"},doc:`Portable Compiled Format (PCF) font is a bitmap font format
originating from X11 Window System. It matches BDF format (which is
text-based) closely, but instead being binary and
platform-independent (as opposed to previously used SNF binary
format) due to introduced features to handle different endianness
and bit order.

The overall composition of the format is straightforward: it's more
or less classic directory of type-offset-size pointers, pointing to
what PCF format calls "tables". Each table carries a certain
piece of information related to the font (metadata properties,
metrics, bitmaps, mapping of glyphs to characters, etc).
`,"doc-ref":"https://fontforge.org/docs/techref/pcf-format.html",seq:[{id:"magic","-orig-id":"header",contents:[1,"fcp"]},{id:"num_tables","-orig-id":"table_count",type:"u4"},{id:"tables",type:"table",repeat:"expr","repeat-expr":"num_tables"}],types:{table:{doc:`Table offers a offset + length pointer to a particular
table. "Type" of table references certain enum. Applications can
ignore enum values which they don't support.
`,"-webide-representation":"{type}",seq:[{id:"type",type:"u4",enum:"types"},{id:"format",type:"format"},{id:"len_body","-orig-id":"size",type:"u4"},{id:"ofs_body","-orig-id":"offset",type:"u4"}],instances:{body:{pos:"ofs_body",size:"len_body",type:{"switch-on":"type",cases:{"types::properties":"properties","types::bitmaps":"bitmaps","types::bdf_encodings":"bdf_encodings","types::swidths":"swidths","types::glyph_names":"glyph_names"}}}},types:{properties:{doc:`Array of properties (key-value pairs), used to convey different X11
settings of a font. Key is always an X font atom.
`,"doc-ref":"https://fontforge.org/docs/techref/pcf-format.html#properties-table","-webide-representation":"{num_props:dec} properties",seq:[{id:"format",type:"format"},{id:"num_props",type:"u4"},{id:"props",type:"prop",repeat:"expr","repeat-expr":"num_props"},{id:"padding",size:"(num_props & 3) == 0 ? 0 : (4 - (num_props & 3))"},{id:"len_strings",type:"u4"},{id:"strings",size:"len_strings",type:"bytes_with_io",doc:`Strings buffer. Never used directly, but instead is
addressed by offsets from the properties.
`}],types:{prop:{doc:`Property is a key-value pair, "key" being always a
string and "value" being either a string or a 32-bit
integer based on an additional flag (\`is_string\`).

Simple offset-based mechanism is employed to keep this
type's sequence fixed-sized and thus have simple access
to property key/value by index.
`,"-webide-representation":"{name} => {str_value}/{int_value}",seq:[{id:"ofs_name",type:"u4",doc:"Offset to name in the strings buffer."},{id:"is_string","-orig-id":"isStringProp",type:"u1",doc:`Designates if value is an integer (zero) or a string (non-zero).
`},{id:"value_or_ofs_value",type:"u4",doc:"If the value is an integer (`is_string` is false),\nthen it's stored here. If the value is a string\n(`is_string` is true), then it stores offset to the\nvalue in the strings buffer.\n"}],instances:{name:{io:"_parent.strings._io",pos:"ofs_name",type:"strz",doc:`Name of the property addressed in the strings buffer.
`,"-webide-parse-mode":"eager"},str_value:{io:"_parent.strings._io",pos:"value_or_ofs_value",type:"strz",if:"is_string != 0",doc:`Value of the property addressed in the strings
buffer, if this is a string value.
`,"-webide-parse-mode":"eager"},int_value:{value:"value_or_ofs_value",if:"is_string == 0",doc:`Value of the property, if this is an integer value.
`,"-webide-parse-mode":"eager"}}}}},bitmaps:{doc:`Table containing uncompressed glyph bitmaps.
`,"doc-ref":"https://fontforge.org/docs/techref/pcf-format.html#the-bitmap-table",seq:[{id:"format",type:"format"},{id:"num_glyphs","-orig-id":"glyph_count",type:"u4"},{id:"offsets",type:"u4",repeat:"expr","repeat-expr":"num_glyphs"},{id:"bitmap_sizes",type:"u4",repeat:"expr","repeat-expr":4}]},bdf_encodings:{doc:`Table that allows mapping of character codes to glyphs present in the
font. Supports 1-byte and 2-byte character codes.

Note that this mapping is agnostic to character encoding itself - it
can represent ASCII, Unicode (ISO/IEC 10646), various single-byte
national encodings, etc. If application cares about it, normally
encoding will be specified in \`properties\` table, in the properties named
\`CHARSET_REGISTRY\` / \`CHARSET_ENCODING\`.
`,"doc-ref":"https://fontforge.org/docs/techref/pcf-format.html#the-encoding-table",seq:[{id:"format",type:"format"},{id:"min_char_or_byte2",type:"u2"},{id:"max_char_or_byte2",type:"u2"},{id:"min_byte1",type:"u2"},{id:"max_byte1",type:"u2"},{id:"default_char",type:"u2"},{id:"glyph_indexes","-orig-id":"glyphindeces",type:"u2",repeat:"expr","repeat-expr":"(max_char_or_byte2 - min_char_or_byte2 + 1) * (max_byte1 - min_byte1 + 1)"}]},swidths:{doc:`Table containing scalable widths of characters.
`,"doc-ref":"https://fontforge.org/docs/techref/pcf-format.html#the-scalable-widths-table","-webide-representation":"{num_glyphs:dec} glyphs",seq:[{id:"format",type:"format"},{id:"num_glyphs",type:"u4"},{id:"swidths",type:"u4",repeat:"expr","repeat-expr":"num_glyphs",doc:`The scalable width of a character is the width of the corresponding
PostScript character in em-units (1/1000ths of an em).
`}]},glyph_names:{doc:`Table containing character names for every glyph.
`,"doc-ref":"https://fontforge.org/docs/techref/pcf-format.html#the-glyph-names-table","-webide-representation":"{num_glyphs:dec} glyphs",seq:[{id:"format",type:"format"},{id:"num_glyphs",type:"u4"},{id:"names",type:"string_ref",repeat:"expr","repeat-expr":"num_glyphs",doc:`Glyph names are represented as string references in strings buffer.
`},{id:"len_strings","-orig-id":"string_size",type:"u4"},{id:"strings",size:"len_strings",type:"bytes_with_io",doc:`Strings buffer which contains all glyph names.
`}],types:{string_ref:{"-webide-representation":"{value}",seq:[{id:"ofs_string",type:"u4"}],instances:{value:{io:"_parent.strings._io",pos:"ofs_string",type:"strz","-webide-parse-mode":"eager"}}}}}}},format:{doc:`Table format specifier, always 4 bytes. Original implementation treats
it as always little-endian and makes liberal use of bitmasking to parse
various parts of it.

TODO: this format specification recognizes endianness and bit
order format bits, but it does not really takes any parsing
decisions based on them.
`,"doc-ref":"https://fontforge.org/docs/techref/pcf-format.html#file-header",seq:[{id:"padding1",type:"b2"},{id:"scan_unit_mask",type:"b2"},{id:"is_most_significant_bit_first","-orig-id":"PCF_BYTE_MASK",type:"b1"},{id:"is_big_endian","-orig-id":"PCF_BYTE_MASK",type:"b1",doc:"If set, then all integers in the table are treated as big-endian"},{id:"glyph_pad_mask",type:"b2","-orig-id":"PCF_GLYPH_PAD_MASK"},{id:"format",type:"u1"},{id:"padding",type:"u2"}]}},enums:{types:{1:{id:"properties","-orig-id":"PCF_PROPERTIES"},2:{id:"accelerators","-orig-id":"PCF_ACCELERATORS"},4:{id:"metrics","-orig-id":"PCF_METRICS"},8:{id:"bitmaps","-orig-id":"PCF_BITMAPS"},16:{id:"ink_metrics","-orig-id":"PCF_INK_METRICS"},32:{id:"bdf_encodings","-orig-id":"PCF_BDF_ENCODINGS"},64:{id:"swidths","-orig-id":"PCF_SWIDTHS"},128:{id:"glyph_names","-orig-id":"PCF_GLYPH_NAMES"},256:{id:"bdf_accelerators","-orig-id":"PCF_BDF_ACCELERATORS"}}}}};export{P as default,T as spec};
