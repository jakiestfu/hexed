import{k as p}from"./index-C9sUxlHS.js";var y=Object.getOwnPropertyNames,u=(o,i)=>function(){return i||(0,o[y(o)[0]])((i={exports:{}}).exports,i),i.exports},b=u({"<stdin>"(o){(function(i,e){typeof define=="function"&&define.amd?define(["exports","kaitai-struct/KaitaiStream"],e):typeof o=="object"&&o!==null&&typeof o.nodeType!="number"?e(o,p.KaitaiStream):e(i.Luks||(i.Luks={}),i.KaitaiStream)})(typeof self<"u"?self:o,function(i,e){var n=(function(){function a(r,_,t){this._io=r,this._parent=_,this._root=t||this,this._debug={},this._read()}a.prototype._read=function(){this._debug.partitionHeader={start:this._io.pos,ioOffset:this._io.byteOffset},this.partitionHeader=new d(this._io,this,this._root),this._debug.partitionHeader.end=this._io.pos};var d=a.PartitionHeader=(function(){function r(t,s,h){this._io=t,this._parent=s,this._root=h,this._debug={},this._read()}r.prototype._read=function(){if(this._debug.magic={start:this._io.pos,ioOffset:this._io.byteOffset},this.magic=this._io.readBytes(6),this._debug.magic.end=this._io.pos,e.byteArrayCompare(this.magic,new Uint8Array([76,85,75,83,186,190]))!=0){var t=new e.ValidationNotEqualError(new Uint8Array([76,85,75,83,186,190]),this.magic,this._io,"/types/partition_header/seq/0");throw this._debug.magic.validationError=t,t}if(this._debug.version={start:this._io.pos,ioOffset:this._io.byteOffset},this.version=this._io.readBytes(2),this._debug.version.end=this._io.pos,e.byteArrayCompare(this.version,new Uint8Array([0,1]))!=0){var t=new e.ValidationNotEqualError(new Uint8Array([0,1]),this.version,this._io,"/types/partition_header/seq/1");throw this._debug.version.validationError=t,t}this._debug.cipherNameSpecification={start:this._io.pos,ioOffset:this._io.byteOffset},this.cipherNameSpecification=e.bytesToStr(this._io.readBytes(32),"ASCII"),this._debug.cipherNameSpecification.end=this._io.pos,this._debug.cipherModeSpecification={start:this._io.pos,ioOffset:this._io.byteOffset},this.cipherModeSpecification=e.bytesToStr(this._io.readBytes(32),"ASCII"),this._debug.cipherModeSpecification.end=this._io.pos,this._debug.hashSpecification={start:this._io.pos,ioOffset:this._io.byteOffset},this.hashSpecification=e.bytesToStr(this._io.readBytes(32),"ASCII"),this._debug.hashSpecification.end=this._io.pos,this._debug.payloadOffset={start:this._io.pos,ioOffset:this._io.byteOffset},this.payloadOffset=this._io.readU4be(),this._debug.payloadOffset.end=this._io.pos,this._debug.numberOfKeyBytes={start:this._io.pos,ioOffset:this._io.byteOffset},this.numberOfKeyBytes=this._io.readU4be(),this._debug.numberOfKeyBytes.end=this._io.pos,this._debug.masterKeyChecksum={start:this._io.pos,ioOffset:this._io.byteOffset},this.masterKeyChecksum=this._io.readBytes(20),this._debug.masterKeyChecksum.end=this._io.pos,this._debug.masterKeySaltParameter={start:this._io.pos,ioOffset:this._io.byteOffset},this.masterKeySaltParameter=this._io.readBytes(32),this._debug.masterKeySaltParameter.end=this._io.pos,this._debug.masterKeyIterationsParameter={start:this._io.pos,ioOffset:this._io.byteOffset},this.masterKeyIterationsParameter=this._io.readU4be(),this._debug.masterKeyIterationsParameter.end=this._io.pos,this._debug.uuid={start:this._io.pos,ioOffset:this._io.byteOffset},this.uuid=e.bytesToStr(this._io.readBytes(40),"ASCII"),this._debug.uuid.end=this._io.pos,this._debug.keySlots={start:this._io.pos,ioOffset:this._io.byteOffset},this._debug.keySlots.arr=[],this.keySlots=[];for(var s=0;s<8;s++)this._debug.keySlots.arr[s]={start:this._io.pos,ioOffset:this._io.byteOffset},this.keySlots.push(new _(this._io,this,this._root)),this._debug.keySlots.arr[s].end=this._io.pos;this._debug.keySlots.end=this._io.pos};var _=r.KeySlot=(function(){t.KeySlotStates=Object.freeze({DISABLED_KEY_SLOT:57005,ENABLED_KEY_SLOT:11301363,57005:"DISABLED_KEY_SLOT",11301363:"ENABLED_KEY_SLOT"});function t(s,h,f){this._io=s,this._parent=h,this._root=f,this._debug={},this._read()}return t.prototype._read=function(){this._debug.stateOfKeySlot={start:this._io.pos,ioOffset:this._io.byteOffset,enumName:"Luks.PartitionHeader.KeySlot.KeySlotStates"},this.stateOfKeySlot=this._io.readU4be(),this._debug.stateOfKeySlot.end=this._io.pos,this._debug.iterationParameter={start:this._io.pos,ioOffset:this._io.byteOffset},this.iterationParameter=this._io.readU4be(),this._debug.iterationParameter.end=this._io.pos,this._debug.saltParameter={start:this._io.pos,ioOffset:this._io.byteOffset},this.saltParameter=this._io.readBytes(32),this._debug.saltParameter.end=this._io.pos,this._debug.startSectorOfKeyMaterial={start:this._io.pos,ioOffset:this._io.byteOffset},this.startSectorOfKeyMaterial=this._io.readU4be(),this._debug.startSectorOfKeyMaterial.end=this._io.pos,this._debug.numberOfAntiForensicStripes={start:this._io.pos,ioOffset:this._io.byteOffset},this.numberOfAntiForensicStripes=this._io.readU4be(),this._debug.numberOfAntiForensicStripes.end=this._io.pos},Object.defineProperty(t.prototype,"keyMaterial",{get:function(){if(this._m_keyMaterial!==void 0)return this._m_keyMaterial;var s=this._io.pos;return this._io.seek(this.startSectorOfKeyMaterial*512),this._debug._m_keyMaterial={start:this._io.pos,ioOffset:this._io.byteOffset},this._m_keyMaterial=this._io.readBytes(this._parent.numberOfKeyBytes*this.numberOfAntiForensicStripes),this._debug._m_keyMaterial.end=this._io.pos,this._io.seek(s),this._m_keyMaterial}}),t})();return r})();return Object.defineProperty(a.prototype,"payload",{get:function(){if(this._m_payload!==void 0)return this._m_payload;var r=this._io.pos;return this._io.seek(this.partitionHeader.payloadOffset*512),this._debug._m_payload={start:this._io.pos,ioOffset:this._io.byteOffset},this._m_payload=this._io.readBytesFull(),this._debug._m_payload.end=this._io.pos,this._io.seek(r),this._m_payload}}),a})();i.Luks=n})}});const l=b(),m={id:"luks",title:"Linux Unified Key Setup",ksy:{meta:{id:"luks",title:"Linux Unified Key Setup",xref:{forensicswiki:"linux_unified_key_setup_(luks)",justsolve:"LUKS",wikidata:"Q29000504"},tags:["filesystem","linux"],license:"CC0-1.0",encoding:"ASCII",endian:"be"},doc:`Linux Unified Key Setup (LUKS) is a format specification for storing disk
encryption parameters and up to 8 user keys (which can unlock the master key).
`,"doc-ref":"https://gitlab.com/cryptsetup/cryptsetup/-/wikis/LUKS-standard/on-disk-format.pdf",seq:[{id:"partition_header",type:"partition_header"}],types:{partition_header:{seq:[{id:"magic",contents:[76,85,75,83,186,190]},{id:"version",contents:[0,1]},{id:"cipher_name_specification",type:"str",size:32},{id:"cipher_mode_specification",type:"str",size:32},{id:"hash_specification",type:"str",size:32},{id:"payload_offset",type:"u4"},{id:"number_of_key_bytes",type:"u4"},{id:"master_key_checksum",size:20},{id:"master_key_salt_parameter",size:32},{id:"master_key_iterations_parameter",type:"u4"},{id:"uuid",type:"str",size:40},{id:"key_slots",type:"key_slot",repeat:"expr","repeat-expr":8}],types:{key_slot:{seq:[{id:"state_of_key_slot",type:"u4",enum:"key_slot_states"},{id:"iteration_parameter",type:"u4"},{id:"salt_parameter",size:32},{id:"start_sector_of_key_material",type:"u4"},{id:"number_of_anti_forensic_stripes",type:"u4"}],instances:{key_material:{pos:"start_sector_of_key_material * 512",size:"_parent.number_of_key_bytes * number_of_anti_forensic_stripes"}},enums:{key_slot_states:{57005:"disabled_key_slot",11301363:"enabled_key_slot"}}}}}},instances:{payload:{pos:"partition_header.payload_offset * 512","size-eos":!0}}}};export{l as default,m as spec};
