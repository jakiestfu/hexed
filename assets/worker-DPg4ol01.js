var M=Object.defineProperty;var N=(n,e,t)=>e in n?M(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var E=(n,e,t)=>N(n,typeof e!="symbol"?e+"":e,t);function R(){return!1}function A(n){const e=R(),t=`[${n}]`;return{log:(...i)=>{e&&console.log(t,...i)}}}class O{constructor(){E(this,"handles",new Map)}async openFile(e,t){const i=await t.getFile(),o={handle:t,size:i.size,lastAccessed:Date.now()};this.handles.set(e,o)}hasFile(e){return this.handles.has(e)}async getFileSize(e){const t=this.handles.get(e);if(!t)throw new Error(`File ${e} is not open`);const i=await t.handle.getFile();return t.size=i.size,t.lastAccessed=Date.now(),i.size}async readByteRange(e,t,i){const o=this.handles.get(e);if(!o)throw new Error(`File ${e} is not open`);const c=await o.handle.getFile(),s=c.size,l=Math.max(0,Math.min(t,s)),h=i>=s?s:Math.max(l,Math.min(i,s));if(l>=s)return new Uint8Array(0);const g=await c.slice(l,h).arrayBuffer(),w=new Uint8Array(g);return o.lastAccessed=Date.now(),o.size=s,w}closeFile(e){this.handles.delete(e)}closeAll(){this.handles.clear()}getOpenFileIds(){return Array.from(this.handles.keys())}getFileInfo(e){return this.handles.get(e)}}const _={size:256*1024,overlap:4*1024,maxCacheSize:10};class b{constructor(){E(this,"windows",new Map);E(this,"configs",new Map)}getConfig(e){return this.configs.has(e)||this.configs.set(e,{..._}),this.configs.get(e)}getWindowKey(e,t){return`${e}-${t}`}async getWindow(e,t,i,o){const c=this.getConfig(e),s=Date.now(),l=Math.floor(t/c.size)*c.size,h=Math.min(l+c.size+c.overlap,i),y=this.getWindowKey(l,h);this.windows.has(e)||this.windows.set(e,new Map);const g=this.windows.get(e),w=g.get(y);if(w){w.lastAccessed=s;const $=t-l,I=i-t;return w.data.slice($,$+I)}const p=await o(l,h),C={start:l,end:h,data:p,lastAccessed:s};this.evictIfNeeded(e,c.maxCacheSize),g.set(y,C);const F=t-l,z=i-t;return p.slice(F,F+z)}evictIfNeeded(e,t){const i=this.windows.get(e);if(!i||i.size<=t)return;const o=Array.from(i.entries());o.sort((s,l)=>s[1].lastAccessed-l[1].lastAccessed);const c=o.length-t;for(let s=0;s<c;s++)i.delete(o[s][0])}setWindowSize(e,t){const i=this.getConfig(e);i.size=t,this.clearCache(e)}clearCache(e){this.windows.delete(e)}clearAllCaches(){this.windows.clear()}getCacheStats(e){const t=this.windows.get(e);if(!t)return{windowCount:0,totalBytes:0};let i=0;for(const o of t.values())i+=o.data.length;return{windowCount:t.size,totalBytes:i}}}const a=A("worker"),d={handleManager:new O,windowManager:new b};function S(){return`${Date.now()}-${Math.random().toString(36).substr(2,9)}`}function f(n){try{n.type==="BYTE_RANGE_RESPONSE"?self.postMessage(n,[n.data.buffer]):self.postMessage(n)}catch(e){console.error("Error sending response:",e)}}function r(n,e){a.log("Error:",n,e?`(request: ${e})`:"");const t={id:S(),type:"ERROR",error:n,originalMessageId:e};f(t)}async function D(n){a.log(`Opening file: ${n.fileId} (request: ${n.id})`);try{await d.handleManager.openFile(n.fileId,n.handle),a.log(`File opened successfully: ${n.fileId}`);const e={id:n.id,type:"CONNECTED"};f(e)}catch(e){r(e instanceof Error?e.message:"Failed to open file",n.id)}}async function W(n){a.log(`Reading byte range: ${n.fileId} [${n.start}-${n.end}] (request: ${n.id})`);try{if(!d.handleManager.hasFile(n.fileId)){r(`File ${n.fileId} is not open`,n.id);return}const e=await d.windowManager.getWindow(n.fileId,n.start,n.end,(i,o)=>d.handleManager.readByteRange(n.fileId,i,o));a.log(`Byte range read successfully: ${n.fileId} [${n.start}-${n.end}], ${e.length} bytes`);const t={id:n.id,type:"BYTE_RANGE_RESPONSE",fileId:n.fileId,start:n.start,end:n.end,data:e};f(t)}catch(e){r(e instanceof Error?e.message:"Failed to read byte range",n.id)}}async function k(n){a.log(`Getting file size: ${n.fileId} (request: ${n.id})`);try{const e=await d.handleManager.getFileSize(n.fileId);a.log(`File size: ${n.fileId} = ${e} bytes`);const t={id:n.id,type:"FILE_SIZE_RESPONSE",fileId:n.fileId,size:e};f(t)}catch(e){r(e instanceof Error?e.message:"Failed to get file size",n.id)}}function u(n){a.log(`Closing file: ${n.fileId} (request: ${n.id})`);try{d.handleManager.closeFile(n.fileId),d.windowManager.clearCache(n.fileId),a.log(`File closed successfully: ${n.fileId}`);const e={id:n.id,type:"CONNECTED"};f(e)}catch(e){r(e instanceof Error?e.message:"Failed to close file",n.id)}}function T(n){a.log(`Setting window size: ${n.fileId} = ${n.windowSize} bytes (request: ${n.id})`);try{d.windowManager.setWindowSize(n.fileId,n.windowSize);const e={id:n.id,type:"CONNECTED"};f(e)}catch(e){r(e instanceof Error?e.message:"Failed to set window size",n.id)}}async function m(n){switch(n.type){case"OPEN_FILE":await D(n);break;case"READ_BYTE_RANGE":await W(n);break;case"GET_FILE_SIZE":await k(n);break;case"CLOSE_FILE":u(n);break;case"SET_WINDOW_SIZE":T(n);break;case"SEARCH_REQUEST":case"CHECKSUM_REQUEST":r(`Operation ${n.type} not yet implemented`,n.id);break;default:const e=n;r(`Unknown message type: ${e.type}`,e.id)}}if(typeof self<"u"){a.log("Worker initialized");const n={id:S(),type:"CONNECTED"};f(n),self.onmessage=e=>{const t=e.data;t.type==="CONNECTED"||t.type.startsWith("RESPONSE")||(a.log(`Received request: ${t.type} (id: ${t.id})`),m(t).catch(i=>{a.log("Unhandled error in request handler:",i),r("Internal error processing request",t.id)}))},self.onerror=e=>{a.log("Worker error:",e)}}
