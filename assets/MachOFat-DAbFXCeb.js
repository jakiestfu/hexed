import{k as f}from"./index-Cy_iKu7E.js";var u=Object.getOwnPropertyNames,p=(i,t)=>function(){return t||(0,i[u(i)[0]])((t={exports:{}}).exports,t),t.exports},d=p({"<stdin>"(i){(function(t,s){typeof define=="function"&&define.amd?define(["exports","kaitai-struct/KaitaiStream","./MachO"],s):typeof i=="object"&&i!==null&&typeof i.nodeType!="number"?s(i,f.KaitaiStream,require("./MachO")):s(t.MachOFat||(t.MachOFat={}),t.KaitaiStream,t.MachO||(t.MachO={}))})(typeof self<"u"?self:i,function(t,s,_){var r=(function(){function h(o,e,a){this._io=o,this._parent=e,this._root=a||this,this._debug={},this._read()}h.prototype._read=function(){if(this._debug.magic={start:this._io.pos,ioOffset:this._io.byteOffset},this.magic=this._io.readBytes(4),this._debug.magic.end=this._io.pos,s.byteArrayCompare(this.magic,new Uint8Array([202,254,186,190]))!=0){var o=new s.ValidationNotEqualError(new Uint8Array([202,254,186,190]),this.magic,this._io,"/seq/0");throw this._debug.magic.validationError=o,o}this._debug.numFatArch={start:this._io.pos,ioOffset:this._io.byteOffset},this.numFatArch=this._io.readU4be(),this._debug.numFatArch.end=this._io.pos,this._debug.fatArchs={start:this._io.pos,ioOffset:this._io.byteOffset},this._debug.fatArchs.arr=[],this.fatArchs=[];for(var e=0;e<this.numFatArch;e++)this._debug.fatArchs.arr[e]={start:this._io.pos,ioOffset:this._io.byteOffset},this.fatArchs.push(new c(this._io,this,this._root)),this._debug.fatArchs.arr[e].end=this._io.pos;this._debug.fatArchs.end=this._io.pos};var c=h.FatArch=(function(){function o(e,a,n){this._io=e,this._parent=a,this._root=n,this._debug={},this._read()}return o.prototype._read=function(){this._debug.cpuType={start:this._io.pos,ioOffset:this._io.byteOffset,enumName:"MachO.CpuType"},this.cpuType=this._io.readU4be(),this._debug.cpuType.end=this._io.pos,this._debug.cpuSubtype={start:this._io.pos,ioOffset:this._io.byteOffset},this.cpuSubtype=this._io.readU4be(),this._debug.cpuSubtype.end=this._io.pos,this._debug.ofsObject={start:this._io.pos,ioOffset:this._io.byteOffset},this.ofsObject=this._io.readU4be(),this._debug.ofsObject.end=this._io.pos,this._debug.lenObject={start:this._io.pos,ioOffset:this._io.byteOffset},this.lenObject=this._io.readU4be(),this._debug.lenObject.end=this._io.pos,this._debug.align={start:this._io.pos,ioOffset:this._io.byteOffset},this.align=this._io.readU4be(),this._debug.align.end=this._io.pos},Object.defineProperty(o.prototype,"object",{get:function(){if(this._m_object!==void 0)return this._m_object;var e=this._io.pos;this._io.seek(this.ofsObject),this._debug._m_object={start:this._io.pos,ioOffset:this._io.byteOffset},this._raw__m_object=this._io.readBytes(this.lenObject);var a=new s(this._raw__m_object);return this._m_object=new _.MachO(a,null,null),this._debug._m_object.end=this._io.pos,this._io.seek(e),this._m_object}}),o})();return h})();t.MachOFat=r})}});const y=d(),m={id:"mach_o_fat",title:'macOS Mach-O multiarch ("fat") binary',ksy:{meta:{id:"mach_o_fat",title:'macOS Mach-O multiarch ("fat") binary',license:"CC0-1.0",imports:["mach_o"],endian:"be"},doc:`This is a simple container format that encapsulates multiple Mach-O files,
each generally for a different architecture. XNU can execute these files just
like single-arch Mach-Os and will pick the appropriate entry.
`,"doc-ref":"https://opensource.apple.com/source/xnu/xnu-7195.121.3/EXTERNAL_HEADERS/mach-o/fat.h.auto.html",seq:[{id:"magic",contents:[202,254,186,190]},{id:"num_fat_arch","-orig-id":"nfat_arch",type:"u4"},{id:"fat_archs",type:"fat_arch",repeat:"expr","repeat-expr":"num_fat_arch"}],types:{fat_arch:{seq:[{id:"cpu_type","-orig-id":"cputype",type:"u4",enum:"mach_o::cpu_type"},{id:"cpu_subtype","-orig-id":"cpusubtype",type:"u4"},{id:"ofs_object","-orig-id":"offset",type:"u4"},{id:"len_object","-orig-id":"size",type:"u4"},{id:"align",type:"u4"}],instances:{object:{pos:"ofs_object",size:"len_object",type:"mach_o"}}}}}};export{y as default,m as spec};
