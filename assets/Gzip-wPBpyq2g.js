import{k as c}from"./index-COA_x_BK.js";var l=Object.getOwnPropertyNames,m=(d,e)=>function(){return e||(0,d[l(d)[0]])((e={exports:{}}).exports,e),e.exports},b=m({"<stdin>"(d){(function(e,h){typeof define=="function"&&define.amd?define(["exports","kaitai-struct/KaitaiStream"],h):typeof d=="object"&&d!==null&&typeof d.nodeType!="number"?h(d,c.KaitaiStream):h(e.Gzip||(e.Gzip={}),e.KaitaiStream)})(typeof self<"u"?self:d,function(e,h){var a=(function(){o.CompressionMethods=Object.freeze({DEFLATE:8,8:"DEFLATE"}),o.Oses=Object.freeze({FAT:0,AMIGA:1,VMS:2,UNIX:3,VM_CMS:4,ATARI_TOS:5,HPFS:6,MACINTOSH:7,Z_SYSTEM:8,CP_M:9,TOPS_20:10,NTFS:11,QDOS:12,ACORN_RISCOS:13,UNKNOWN:255,0:"FAT",1:"AMIGA",2:"VMS",3:"UNIX",4:"VM_CMS",5:"ATARI_TOS",6:"HPFS",7:"MACINTOSH",8:"Z_SYSTEM",9:"CP_M",10:"TOPS_20",11:"NTFS",12:"QDOS",13:"ACORN_RISCOS",255:"UNKNOWN"});function o(i,s,t){this._io=i,this._parent=s,this._root=t||this,this._debug={},this._read()}o.prototype._read=function(){if(this._debug.magic={start:this._io.pos,ioOffset:this._io.byteOffset},this.magic=this._io.readBytes(2),this._debug.magic.end=this._io.pos,h.byteArrayCompare(this.magic,new Uint8Array([31,139]))!=0){var i=new h.ValidationNotEqualError(new Uint8Array([31,139]),this.magic,this._io,"/seq/0");throw this._debug.magic.validationError=i,i}switch(this._debug.compressionMethod={start:this._io.pos,ioOffset:this._io.byteOffset,enumName:"Gzip.CompressionMethods"},this.compressionMethod=this._io.readU1(),this._debug.compressionMethod.end=this._io.pos,this._debug.flags={start:this._io.pos,ioOffset:this._io.byteOffset},this.flags=new f(this._io,this,this._root),this._debug.flags.end=this._io.pos,this._debug.modTime={start:this._io.pos,ioOffset:this._io.byteOffset},this.modTime=this._io.readU4le(),this._debug.modTime.end=this._io.pos,this._debug.extraFlags={start:this._io.pos,ioOffset:this._io.byteOffset},this.compressionMethod){case o.CompressionMethods.DEFLATE:this.extraFlags=new n(this._io,this,this._root);break}this._debug.extraFlags.end=this._io.pos,this._debug.os={start:this._io.pos,ioOffset:this._io.byteOffset,enumName:"Gzip.Oses"},this.os=this._io.readU1(),this._debug.os.end=this._io.pos,this.flags.hasExtra&&(this._debug.extras={start:this._io.pos,ioOffset:this._io.byteOffset},this.extras=new _(this._io,this,this._root),this._debug.extras.end=this._io.pos),this.flags.hasName&&(this._debug.name={start:this._io.pos,ioOffset:this._io.byteOffset},this.name=this._io.readBytesTerm(0,!1,!0,!0),this._debug.name.end=this._io.pos),this.flags.hasComment&&(this._debug.comment={start:this._io.pos,ioOffset:this._io.byteOffset},this.comment=this._io.readBytesTerm(0,!1,!0,!0),this._debug.comment.end=this._io.pos),this.flags.hasHeaderCrc&&(this._debug.headerCrc16={start:this._io.pos,ioOffset:this._io.byteOffset},this.headerCrc16=this._io.readU2le(),this._debug.headerCrc16.end=this._io.pos),this._debug.body={start:this._io.pos,ioOffset:this._io.byteOffset},this.body=this._io.readBytes(this._io.size-this._io.pos-8),this._debug.body.end=this._io.pos,this._debug.bodyCrc32={start:this._io.pos,ioOffset:this._io.byteOffset},this.bodyCrc32=this._io.readU4le(),this._debug.bodyCrc32.end=this._io.pos,this._debug.lenUncompressed={start:this._io.pos,ioOffset:this._io.byteOffset},this.lenUncompressed=this._io.readU4le(),this._debug.lenUncompressed.end=this._io.pos};var n=o.ExtraFlagsDeflate=(function(){i.CompressionStrengths=Object.freeze({BEST:2,FAST:4,2:"BEST",4:"FAST"});function i(s,t,r){this._io=s,this._parent=t,this._root=r,this._debug={},this._read()}return i.prototype._read=function(){this._debug.compressionStrength={start:this._io.pos,ioOffset:this._io.byteOffset,enumName:"Gzip.ExtraFlagsDeflate.CompressionStrengths"},this.compressionStrength=this._io.readU1(),this._debug.compressionStrength.end=this._io.pos},i})(),_=o.Extras=(function(){function i(s,t,r){this._io=s,this._parent=t,this._root=r,this._debug={},this._read()}return i.prototype._read=function(){this._debug.lenSubfields={start:this._io.pos,ioOffset:this._io.byteOffset},this.lenSubfields=this._io.readU2le(),this._debug.lenSubfields.end=this._io.pos,this._debug.subfields={start:this._io.pos,ioOffset:this._io.byteOffset},this._raw_subfields=this._io.readBytes(this.lenSubfields);var s=new h(this._raw_subfields);this.subfields=new u(s,this,this._root),this._debug.subfields.end=this._io.pos},i})(),f=o.Flags=(function(){function i(s,t,r){this._io=s,this._parent=t,this._root=r,this._debug={},this._read()}return i.prototype._read=function(){this._debug.reserved1={start:this._io.pos,ioOffset:this._io.byteOffset},this.reserved1=this._io.readBitsIntBe(3),this._debug.reserved1.end=this._io.pos,this._debug.hasComment={start:this._io.pos,ioOffset:this._io.byteOffset},this.hasComment=this._io.readBitsIntBe(1)!=0,this._debug.hasComment.end=this._io.pos,this._debug.hasName={start:this._io.pos,ioOffset:this._io.byteOffset},this.hasName=this._io.readBitsIntBe(1)!=0,this._debug.hasName.end=this._io.pos,this._debug.hasExtra={start:this._io.pos,ioOffset:this._io.byteOffset},this.hasExtra=this._io.readBitsIntBe(1)!=0,this._debug.hasExtra.end=this._io.pos,this._debug.hasHeaderCrc={start:this._io.pos,ioOffset:this._io.byteOffset},this.hasHeaderCrc=this._io.readBitsIntBe(1)!=0,this._debug.hasHeaderCrc.end=this._io.pos,this._debug.isText={start:this._io.pos,ioOffset:this._io.byteOffset},this.isText=this._io.readBitsIntBe(1)!=0,this._debug.isText.end=this._io.pos},i})(),p=o.Subfield=(function(){function i(s,t,r){this._io=s,this._parent=t,this._root=r,this._debug={},this._read()}return i.prototype._read=function(){this._debug.id={start:this._io.pos,ioOffset:this._io.byteOffset},this.id=this._io.readU2le(),this._debug.id.end=this._io.pos,this._debug.lenData={start:this._io.pos,ioOffset:this._io.byteOffset},this.lenData=this._io.readU2le(),this._debug.lenData.end=this._io.pos,this._debug.data={start:this._io.pos,ioOffset:this._io.byteOffset},this.data=this._io.readBytes(this.lenData),this._debug.data.end=this._io.pos},i})(),u=o.Subfields=(function(){function i(s,t,r){this._io=s,this._parent=t,this._root=r,this._debug={},this._read()}return i.prototype._read=function(){for(this._debug.entries={start:this._io.pos,ioOffset:this._io.byteOffset},this._debug.entries.arr=[],this.entries=[];!this._io.isEof();)this._debug.entries.arr[this.entries.length]={start:this._io.pos,ioOffset:this._io.byteOffset},this.entries.push(new p(this._io,this,this._root)),this._debug.entries.arr[this.entries.length-1].end=this._io.pos;this._debug.entries.end=this._io.pos},i})();return o})();e.Gzip=a})}});const y=b(),O={id:"gzip",title:"gzip",ksy:{meta:{id:"gzip","file-extension":"gz",xref:{forensicswiki:"gzip",justsolve:"Gzip",mime:"application/gzip",pronom:"x-fmt/266",rfc:1952,wikidata:"Q10287816"},license:"CC0-1.0",endian:"le"},doc:`Gzip is a popular and standard single-file archiving format. It
essentially provides a container that stores original file name,
timestamp and a few other things (like optional comment), basic
CRCs, etc, and a file compressed by a chosen compression algorithm.

As of 2019, there is actually only one working solution for
compression algorithms, so it's typically raw DEFLATE stream
(without zlib header) in all gzipped files.
`,"doc-ref":"https://www.rfc-editor.org/rfc/rfc1952",seq:[{id:"magic","-orig-id":"ID1, ID2",contents:[31,139]},{id:"compression_method","-orig-id":"CM",type:"u1",enum:"compression_methods",doc:`Compression method used to compress file body. In practice, only
one method is widely used: 8 = deflate.
`},{id:"flags","-orig-id":"FLG",type:"flags"},{id:"mod_time","-orig-id":"MTIME",type:"u4",doc:"Last modification time of a file archived in UNIX timestamp format."},{id:"extra_flags","-orig-id":"XFL",type:{"switch-on":"compression_method",cases:{"compression_methods::deflate":"extra_flags_deflate"}},doc:"Extra flags, specific to compression method chosen."},{id:"os","-orig-id":"OS",type:"u1",enum:"oses",doc:"OS used to compress this file."},{id:"extras",type:"extras",if:"flags.has_extra"},{id:"name",terminator:0,if:"flags.has_name"},{id:"comment",terminator:0,if:"flags.has_comment"},{id:"header_crc16",type:"u2",if:"flags.has_header_crc"},{id:"body",size:"_io.size - _io.pos - 8",doc:`Compressed body of a file archived. Note that we don't make an
attempt to decompress it here.
`},{id:"body_crc32","-orig-id":"CRC32",type:"u4",doc:`CRC32 checksum of an uncompressed file body
`},{id:"len_uncompressed","-orig-id":"ISIZE",type:"u4",doc:`Size of original uncompressed data in bytes (truncated to 32
bits).
`}],enums:{compression_methods:{8:"deflate"},oses:{0:{id:"fat",doc:"FAT filesystem (MS-DOS, OS/2, NT/Win32)"},1:{id:"amiga",doc:"Amiga"},2:{id:"vms",doc:"VMS (or OpenVMS)"},3:{id:"unix",doc:"Unix"},4:{id:"vm_cms",doc:"VM/CMS"},5:{id:"atari_tos",doc:"Atari TOS"},6:{id:"hpfs",doc:"HPFS filesystem (OS/2, NT)"},7:{id:"macintosh",doc:"Macintosh"},8:{id:"z_system",doc:"Z-System"},9:{id:"cp_m",doc:"CP/M"},10:{id:"tops_20",doc:"TOPS-20"},11:{id:"ntfs",doc:"NTFS filesystem (NT)"},12:{id:"qdos",doc:"QDOS"},13:{id:"acorn_riscos",doc:"Acorn RISCOS"},255:{id:"unknown"}}},types:{flags:{seq:[{id:"reserved1",type:"b3"},{id:"has_comment","-orig-id":"FCOMMENT",type:"b1"},{id:"has_name","-orig-id":"FNAME",type:"b1"},{id:"has_extra","-orig-id":"FEXTRA",type:"b1",doc:"If true, optional extra fields are present in the archive."},{id:"has_header_crc","-orig-id":"FHCRC",type:"b1",doc:`If true, this archive includes a CRC16 checksum for the header.
`},{id:"is_text","-orig-id":"FTEXT",type:"b1",doc:`If true, file inside this archive is a text file from
compressor's point of view.
`}]},extra_flags_deflate:{seq:[{id:"compression_strength",type:"u1",enum:"compression_strengths"}],enums:{compression_strengths:{2:"best",4:"fast"}}},extras:{seq:[{id:"len_subfields","-orig-id":"XLEN",type:"u2"},{id:"subfields",size:"len_subfields",type:"subfields"}]},subfields:{doc:`Container for many subfields, constrained by size of stream.
`,seq:[{id:"entries",type:"subfield",repeat:"eos"}]},subfield:{doc:`Every subfield follows typical [TLV scheme](https://en.wikipedia.org/wiki/Type-length-value):

* \`id\` serves role of "T"ype
* \`len_data\` serves role of "L"ength
* \`data\` serves role of "V"alue

This way it's possible to for arbitrary parser to skip over
subfields it does not support.
`,seq:[{id:"id","-orig-id":"SI1, SI2",type:"u2",doc:"Subfield ID, typically two ASCII letters."},{id:"len_data",type:"u2"},{id:"data",size:"len_data"}]}}}};export{y as default,O as spec};
