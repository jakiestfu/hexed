import{k as b}from"./index-DZ3xxA7Z.js";var p=Object.getOwnPropertyNames,f=(s,i)=>function(){return i||(0,s[p(s)[0]])((i={exports:{}}).exports,i),i.exports},u=f({"<stdin>"(s){(function(i,o){typeof define=="function"&&define.amd?define(["exports","kaitai-struct/KaitaiStream"],o):typeof s=="object"&&s!==null&&typeof s.nodeType!="number"?o(s,b.KaitaiStream):o(i.MbrPartitionTable||(i.MbrPartitionTable={}),i.KaitaiStream)})(typeof self<"u"?self:s,function(i,o){var _=(function(){function n(t,e,r){this._io=t,this._parent=e,this._root=r||this,this._debug={},this._read()}n.prototype._read=function(){this._debug.bootstrapCode={start:this._io.pos,ioOffset:this._io.byteOffset},this.bootstrapCode=this._io.readBytes(446),this._debug.bootstrapCode.end=this._io.pos,this._debug.partitions={start:this._io.pos,ioOffset:this._io.byteOffset},this._debug.partitions.arr=[],this.partitions=[];for(var t=0;t<4;t++)this._debug.partitions.arr[t]={start:this._io.pos,ioOffset:this._io.byteOffset},this.partitions.push(new d(this._io,this,this._root)),this._debug.partitions.arr[t].end=this._io.pos;if(this._debug.partitions.end=this._io.pos,this._debug.bootSignature={start:this._io.pos,ioOffset:this._io.byteOffset},this.bootSignature=this._io.readBytes(2),this._debug.bootSignature.end=this._io.pos,o.byteArrayCompare(this.bootSignature,new Uint8Array([85,170]))!=0){var e=new o.ValidationNotEqualError(new Uint8Array([85,170]),this.bootSignature,this._io,"/seq/2");throw this._debug.bootSignature.validationError=e,e}};var h=n.Chs=(function(){function t(e,r,a){this._io=e,this._parent=r,this._root=a,this._debug={},this._read()}return t.prototype._read=function(){this._debug.head={start:this._io.pos,ioOffset:this._io.byteOffset},this.head=this._io.readU1(),this._debug.head.end=this._io.pos,this._debug.b2={start:this._io.pos,ioOffset:this._io.byteOffset},this.b2=this._io.readU1(),this._debug.b2.end=this._io.pos,this._debug.b3={start:this._io.pos,ioOffset:this._io.byteOffset},this.b3=this._io.readU1(),this._debug.b3.end=this._io.pos},Object.defineProperty(t.prototype,"cylinder",{get:function(){return this._m_cylinder!==void 0?this._m_cylinder:(this._debug._m_cylinder={},this._m_cylinder=this.b3+((this.b2&192)<<2),this._m_cylinder)}}),Object.defineProperty(t.prototype,"sector",{get:function(){return this._m_sector!==void 0?this._m_sector:(this._debug._m_sector={},this._m_sector=this.b2&63,this._m_sector)}}),t})(),d=n.PartitionEntry=(function(){function t(e,r,a){this._io=e,this._parent=r,this._root=a,this._debug={},this._read()}return t.prototype._read=function(){this._debug.status={start:this._io.pos,ioOffset:this._io.byteOffset},this.status=this._io.readU1(),this._debug.status.end=this._io.pos,this._debug.chsStart={start:this._io.pos,ioOffset:this._io.byteOffset},this.chsStart=new h(this._io,this,this._root),this._debug.chsStart.end=this._io.pos,this._debug.partitionType={start:this._io.pos,ioOffset:this._io.byteOffset},this.partitionType=this._io.readU1(),this._debug.partitionType.end=this._io.pos,this._debug.chsEnd={start:this._io.pos,ioOffset:this._io.byteOffset},this.chsEnd=new h(this._io,this,this._root),this._debug.chsEnd.end=this._io.pos,this._debug.lbaStart={start:this._io.pos,ioOffset:this._io.byteOffset},this.lbaStart=this._io.readU4le(),this._debug.lbaStart.end=this._io.pos,this._debug.numSectors={start:this._io.pos,ioOffset:this._io.byteOffset},this.numSectors=this._io.readU4le(),this._debug.numSectors.end=this._io.pos},t})();return n})();i.MbrPartitionTable=_})}});const y=u(),l={id:"mbr_partition_table",title:"MBR (Master Boot Record) partition table",ksy:{meta:{id:"mbr_partition_table",title:"MBR (Master Boot Record) partition table",xref:{forensicswiki:"master_boot_record",justsolve:"Master_Boot_Record",wikidata:"Q624752"},tags:["dos"],license:"CC0-1.0",endian:"le"},doc:`MBR (Master Boot Record) partition table is a traditional way of
MS-DOS to partition larger hard disc drives into distinct
partitions.

This table is stored in the end of the boot sector (first sector) of
the drive, after the bootstrap code. Original DOS 2.0 specification
allowed only 4 partitions per disc, but DOS 3.2 introduced concept
of "extended partitions", which work as nested extra "boot records"
which are pointed to by original ("primary") partitions in MBR.
`,seq:[{id:"bootstrap_code",size:446},{id:"partitions",type:"partition_entry",repeat:"expr","repeat-expr":4},{id:"boot_signature",contents:[85,170]}],types:{partition_entry:{seq:[{id:"status",type:"u1"},{id:"chs_start",type:"chs"},{id:"partition_type",type:"u1"},{id:"chs_end",type:"chs"},{id:"lba_start",type:"u4"},{id:"num_sectors",type:"u4"}]},chs:{seq:[{id:"head",type:"u1"},{id:"b2",type:"u1"},{id:"b3",type:"u1"}],instances:{sector:{value:"b2 & 0b111111"},cylinder:{value:"b3 + ((b2 & 0b11000000) << 2)"}}}}}};export{y as default,l as spec};
