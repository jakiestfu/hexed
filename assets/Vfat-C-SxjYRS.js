import{k as m}from"./index-COA_x_BK.js";var g=Object.getOwnPropertyNames,O=(h,r)=>function(){return r||(0,h[g(h)[0]])((r={exports:{}}).exports,r),r.exports},v=O({"<stdin>"(h){(function(r,i){typeof define=="function"&&define.amd?define(["exports","kaitai-struct/KaitaiStream","./DosDatetime"],i):typeof h=="object"&&h!==null&&typeof h.nodeType!="number"?i(h,m.KaitaiStream,require("./DosDatetime")):i(r.Vfat||(r.Vfat={}),r.KaitaiStream,r.DosDatetime||(r.DosDatetime={}))})(typeof self<"u"?self:h,function(r,i,a){var n=(function(){function _(t,e,s){this._io=t,this._parent=e,this._root=s||this,this._debug={},this._read()}_.prototype._read=function(){this._debug.bootSector={start:this._io.pos,ioOffset:this._io.byteOffset},this.bootSector=new b(this._io,this,this._root),this._debug.bootSector.end=this._io.pos};var f=_.BiosParamBlock=(function(){function t(e,s,o){this._io=e,this._parent=s,this._root=o,this._debug={},this._read()}return t.prototype._read=function(){this._debug.bytesPerLs={start:this._io.pos,ioOffset:this._io.byteOffset},this.bytesPerLs=this._io.readU2le(),this._debug.bytesPerLs.end=this._io.pos,this._debug.lsPerClus={start:this._io.pos,ioOffset:this._io.byteOffset},this.lsPerClus=this._io.readU1(),this._debug.lsPerClus.end=this._io.pos,this._debug.numReservedLs={start:this._io.pos,ioOffset:this._io.byteOffset},this.numReservedLs=this._io.readU2le(),this._debug.numReservedLs.end=this._io.pos,this._debug.numFats={start:this._io.pos,ioOffset:this._io.byteOffset},this.numFats=this._io.readU1(),this._debug.numFats.end=this._io.pos,this._debug.maxRootDirRec={start:this._io.pos,ioOffset:this._io.byteOffset},this.maxRootDirRec=this._io.readU2le(),this._debug.maxRootDirRec.end=this._io.pos,this._debug.totalLs2={start:this._io.pos,ioOffset:this._io.byteOffset},this.totalLs2=this._io.readU2le(),this._debug.totalLs2.end=this._io.pos,this._debug.mediaCode={start:this._io.pos,ioOffset:this._io.byteOffset},this.mediaCode=this._io.readU1(),this._debug.mediaCode.end=this._io.pos,this._debug.lsPerFat={start:this._io.pos,ioOffset:this._io.byteOffset},this.lsPerFat=this._io.readU2le(),this._debug.lsPerFat.end=this._io.pos,this._debug.psPerTrack={start:this._io.pos,ioOffset:this._io.byteOffset},this.psPerTrack=this._io.readU2le(),this._debug.psPerTrack.end=this._io.pos,this._debug.numHeads={start:this._io.pos,ioOffset:this._io.byteOffset},this.numHeads=this._io.readU2le(),this._debug.numHeads.end=this._io.pos,this._debug.numHiddenSectors={start:this._io.pos,ioOffset:this._io.byteOffset},this.numHiddenSectors=this._io.readU4le(),this._debug.numHiddenSectors.end=this._io.pos,this._debug.totalLs4={start:this._io.pos,ioOffset:this._io.byteOffset},this.totalLs4=this._io.readU4le(),this._debug.totalLs4.end=this._io.pos},t})(),b=_.BootSector=(function(){function t(e,s,o){this._io=e,this._parent=s,this._root=o,this._debug={},this._read()}return t.prototype._read=function(){this._debug.jmpInstruction={start:this._io.pos,ioOffset:this._io.byteOffset},this.jmpInstruction=this._io.readBytes(3),this._debug.jmpInstruction.end=this._io.pos,this._debug.oemName={start:this._io.pos,ioOffset:this._io.byteOffset},this.oemName=i.bytesToStr(i.bytesStripRight(this._io.readBytes(8),32),"ASCII"),this._debug.oemName.end=this._io.pos,this._debug.bpb={start:this._io.pos,ioOffset:this._io.byteOffset},this.bpb=new f(this._io,this,this._root),this._debug.bpb.end=this._io.pos,this.isFat32||(this._debug.ebpbFat16={start:this._io.pos,ioOffset:this._io.byteOffset},this.ebpbFat16=new p(this._io,this,this._root),this._debug.ebpbFat16.end=this._io.pos),this.isFat32&&(this._debug.ebpbFat32={start:this._io.pos,ioOffset:this._io.byteOffset},this.ebpbFat32=new u(this._io,this,this._root),this._debug.ebpbFat32.end=this._io.pos)},Object.defineProperty(t.prototype,"isFat32",{get:function(){return this._m_isFat32!==void 0?this._m_isFat32:(this._debug._m_isFat32={},this._m_isFat32=this.bpb.maxRootDirRec==0,this._m_isFat32)}}),Object.defineProperty(t.prototype,"lsPerFat",{get:function(){return this._m_lsPerFat!==void 0?this._m_lsPerFat:(this._debug._m_lsPerFat={},this._m_lsPerFat=this.isFat32?this.ebpbFat32.lsPerFat:this.bpb.lsPerFat,this._m_lsPerFat)}}),Object.defineProperty(t.prototype,"lsPerRootDir",{get:function(){return this._m_lsPerRootDir!==void 0?this._m_lsPerRootDir:(this._debug._m_lsPerRootDir={},this._m_lsPerRootDir=Math.floor((this.bpb.maxRootDirRec*32+this.bpb.bytesPerLs-1)/this.bpb.bytesPerLs),this._m_lsPerRootDir)}}),Object.defineProperty(t.prototype,"posFats",{get:function(){return this._m_posFats!==void 0?this._m_posFats:(this._debug._m_posFats={},this._m_posFats=this.bpb.bytesPerLs*this.bpb.numReservedLs,this._m_posFats)}}),Object.defineProperty(t.prototype,"posRootDir",{get:function(){return this._m_posRootDir!==void 0?this._m_posRootDir:(this._debug._m_posRootDir={},this._m_posRootDir=this.bpb.bytesPerLs*(this.bpb.numReservedLs+this.lsPerFat*this.bpb.numFats),this._m_posRootDir)}}),Object.defineProperty(t.prototype,"sizeFat",{get:function(){return this._m_sizeFat!==void 0?this._m_sizeFat:(this._debug._m_sizeFat={},this._m_sizeFat=this.bpb.bytesPerLs*this.lsPerFat,this._m_sizeFat)}}),Object.defineProperty(t.prototype,"sizeRootDir",{get:function(){return this._m_sizeRootDir!==void 0?this._m_sizeRootDir:(this._debug._m_sizeRootDir={},this._m_sizeRootDir=this.lsPerRootDir*this.bpb.bytesPerLs,this._m_sizeRootDir)}}),t})(),p=_.ExtBiosParamBlockFat16=(function(){function t(e,s,o){this._io=e,this._parent=s,this._root=o,this._debug={},this._read()}return t.prototype._read=function(){this._debug.physDriveNum={start:this._io.pos,ioOffset:this._io.byteOffset},this.physDriveNum=this._io.readU1(),this._debug.physDriveNum.end=this._io.pos,this._debug.reserved1={start:this._io.pos,ioOffset:this._io.byteOffset},this.reserved1=this._io.readU1(),this._debug.reserved1.end=this._io.pos,this._debug.extBootSign={start:this._io.pos,ioOffset:this._io.byteOffset},this.extBootSign=this._io.readU1(),this._debug.extBootSign.end=this._io.pos,this._debug.volumeId={start:this._io.pos,ioOffset:this._io.byteOffset},this.volumeId=this._io.readBytes(4),this._debug.volumeId.end=this._io.pos,this._debug.partitionVolumeLabel={start:this._io.pos,ioOffset:this._io.byteOffset},this.partitionVolumeLabel=i.bytesToStr(i.bytesStripRight(this._io.readBytes(11),32),"ASCII"),this._debug.partitionVolumeLabel.end=this._io.pos,this._debug.fsTypeStr={start:this._io.pos,ioOffset:this._io.byteOffset},this.fsTypeStr=i.bytesToStr(i.bytesStripRight(this._io.readBytes(8),32),"ASCII"),this._debug.fsTypeStr.end=this._io.pos},t})(),u=_.ExtBiosParamBlockFat32=(function(){function t(e,s,o){this._io=e,this._parent=s,this._root=o,this._debug={},this._read()}return t.prototype._read=function(){if(this._debug.lsPerFat={start:this._io.pos,ioOffset:this._io.byteOffset},this.lsPerFat=this._io.readU4le(),this._debug.lsPerFat.end=this._io.pos,this._debug.hasActiveFat={start:this._io.pos,ioOffset:this._io.byteOffset},this.hasActiveFat=this._io.readBitsIntLe(1)!=0,this._debug.hasActiveFat.end=this._io.pos,this._debug.reserved1={start:this._io.pos,ioOffset:this._io.byteOffset},this.reserved1=this._io.readBitsIntLe(3),this._debug.reserved1.end=this._io.pos,this._debug.activeFatId={start:this._io.pos,ioOffset:this._io.byteOffset},this.activeFatId=this._io.readBitsIntLe(4),this._debug.activeFatId.end=this._io.pos,this._io.alignToByte(),this._debug.reserved2={start:this._io.pos,ioOffset:this._io.byteOffset},this.reserved2=this._io.readBytes(1),this._debug.reserved2.end=this._io.pos,i.byteArrayCompare(this.reserved2,new Uint8Array([0]))!=0){var e=new i.ValidationNotEqualError(new Uint8Array([0]),this.reserved2,this._io,"/types/ext_bios_param_block_fat32/seq/4");throw this._debug.reserved2.validationError=e,e}this._debug.fatVersion={start:this._io.pos,ioOffset:this._io.byteOffset},this.fatVersion=this._io.readU2le(),this._debug.fatVersion.end=this._io.pos,this._debug.rootDirStartClus={start:this._io.pos,ioOffset:this._io.byteOffset},this.rootDirStartClus=this._io.readU4le(),this._debug.rootDirStartClus.end=this._io.pos,this._debug.lsFsInfo={start:this._io.pos,ioOffset:this._io.byteOffset},this.lsFsInfo=this._io.readU2le(),this._debug.lsFsInfo.end=this._io.pos,this._debug.bootSectorsCopyStartLs={start:this._io.pos,ioOffset:this._io.byteOffset},this.bootSectorsCopyStartLs=this._io.readU2le(),this._debug.bootSectorsCopyStartLs.end=this._io.pos,this._debug.reserved3={start:this._io.pos,ioOffset:this._io.byteOffset},this.reserved3=this._io.readBytes(12),this._debug.reserved3.end=this._io.pos,this._debug.physDriveNum={start:this._io.pos,ioOffset:this._io.byteOffset},this.physDriveNum=this._io.readU1(),this._debug.physDriveNum.end=this._io.pos,this._debug.reserved4={start:this._io.pos,ioOffset:this._io.byteOffset},this.reserved4=this._io.readU1(),this._debug.reserved4.end=this._io.pos,this._debug.extBootSign={start:this._io.pos,ioOffset:this._io.byteOffset},this.extBootSign=this._io.readU1(),this._debug.extBootSign.end=this._io.pos,this._debug.volumeId={start:this._io.pos,ioOffset:this._io.byteOffset},this.volumeId=this._io.readBytes(4),this._debug.volumeId.end=this._io.pos,this._debug.partitionVolumeLabel={start:this._io.pos,ioOffset:this._io.byteOffset},this.partitionVolumeLabel=i.bytesToStr(i.bytesStripRight(this._io.readBytes(11),32),"ASCII"),this._debug.partitionVolumeLabel.end=this._io.pos,this._debug.fsTypeStr={start:this._io.pos,ioOffset:this._io.byteOffset},this.fsTypeStr=i.bytesToStr(i.bytesStripRight(this._io.readBytes(8),32),"ASCII"),this._debug.fsTypeStr.end=this._io.pos},t})(),l=_.RootDirectory=(function(){function t(e,s,o){this._io=e,this._parent=s,this._root=o,this._debug={},this._read()}return t.prototype._read=function(){this._debug.records={start:this._io.pos,ioOffset:this._io.byteOffset},this._debug.records.arr=[],this.records=[];for(var e=0;e<this._root.bootSector.bpb.maxRootDirRec;e++)this._debug.records.arr[e]={start:this._io.pos,ioOffset:this._io.byteOffset},this.records.push(new c(this._io,this,this._root)),this._debug.records.arr[e].end=this._io.pos;this._debug.records.end=this._io.pos},t})(),c=_.RootDirectoryRec=(function(){function t(s,o,d){this._io=s,this._parent=o,this._root=d,this._debug={},this._read()}t.prototype._read=function(){this._debug.fileName={start:this._io.pos,ioOffset:this._io.byteOffset},this.fileName=this._io.readBytes(11),this._debug.fileName.end=this._io.pos,this._debug.attrs={start:this._io.pos,ioOffset:this._io.byteOffset},this._raw_attrs=this._io.readBytes(1);var s=new i(this._raw_attrs);this.attrs=new e(s,this,this._root),this._debug.attrs.end=this._io.pos,this._debug.reserved={start:this._io.pos,ioOffset:this._io.byteOffset},this.reserved=this._io.readBytes(10),this._debug.reserved.end=this._io.pos,this._debug.lastWriteTime={start:this._io.pos,ioOffset:this._io.byteOffset},this._raw_lastWriteTime=this._io.readBytes(4);var o=new i(this._raw_lastWriteTime);this.lastWriteTime=new a.DosDatetime(o,null,null),this._debug.lastWriteTime.end=this._io.pos,this._debug.startClus={start:this._io.pos,ioOffset:this._io.byteOffset},this.startClus=this._io.readU2le(),this._debug.startClus.end=this._io.pos,this._debug.fileSize={start:this._io.pos,ioOffset:this._io.byteOffset},this.fileSize=this._io.readU4le(),this._debug.fileSize.end=this._io.pos};var e=t.AttrFlags=(function(){function s(o,d,y){this._io=o,this._parent=d,this._root=y,this._debug={},this._read()}return s.prototype._read=function(){this._debug.readOnly={start:this._io.pos,ioOffset:this._io.byteOffset},this.readOnly=this._io.readBitsIntLe(1)!=0,this._debug.readOnly.end=this._io.pos,this._debug.hidden={start:this._io.pos,ioOffset:this._io.byteOffset},this.hidden=this._io.readBitsIntLe(1)!=0,this._debug.hidden.end=this._io.pos,this._debug.system={start:this._io.pos,ioOffset:this._io.byteOffset},this.system=this._io.readBitsIntLe(1)!=0,this._debug.system.end=this._io.pos,this._debug.volumeId={start:this._io.pos,ioOffset:this._io.byteOffset},this.volumeId=this._io.readBitsIntLe(1)!=0,this._debug.volumeId.end=this._io.pos,this._debug.isDirectory={start:this._io.pos,ioOffset:this._io.byteOffset},this.isDirectory=this._io.readBitsIntLe(1)!=0,this._debug.isDirectory.end=this._io.pos,this._debug.archive={start:this._io.pos,ioOffset:this._io.byteOffset},this.archive=this._io.readBitsIntLe(1)!=0,this._debug.archive.end=this._io.pos,this._debug.reserved={start:this._io.pos,ioOffset:this._io.byteOffset},this.reserved=this._io.readBitsIntLe(2),this._debug.reserved.end=this._io.pos},Object.defineProperty(s.prototype,"longName",{get:function(){return this._m_longName!==void 0?this._m_longName:(this._debug._m_longName={},this._m_longName=this.readOnly&&this.hidden&&this.system&&this.volumeId,this._m_longName)}}),s})();return t})();return Object.defineProperty(_.prototype,"fats",{get:function(){if(this._m_fats!==void 0)return this._m_fats;var t=this._io.pos;this._io.seek(this.bootSector.posFats),this._debug._m_fats={start:this._io.pos,ioOffset:this._io.byteOffset},this._debug._m_fats.arr=[],this._m_fats=[];for(var e=0;e<this.bootSector.bpb.numFats;e++)this._debug._m_fats.arr[e]={start:this._io.pos,ioOffset:this._io.byteOffset},this._m_fats.push(this._io.readBytes(this.bootSector.sizeFat)),this._debug._m_fats.arr[e].end=this._io.pos;return this._debug._m_fats.end=this._io.pos,this._io.seek(t),this._m_fats}}),Object.defineProperty(_.prototype,"rootDir",{get:function(){if(this._m_rootDir!==void 0)return this._m_rootDir;var t=this._io.pos;this._io.seek(this.bootSector.posRootDir),this._debug._m_rootDir={start:this._io.pos,ioOffset:this._io.byteOffset},this._raw__m_rootDir=this._io.readBytes(this.bootSector.sizeRootDir);var e=new i(this._raw__m_rootDir);return this._m_rootDir=new l(e,this,this._root),this._debug._m_rootDir.end=this._io.pos,this._io.seek(t),this._m_rootDir}}),_})();r.Vfat=n})}});const B=v(),P={id:"vfat",title:"vfat",ksy:{meta:{id:"vfat",xref:{forensicswiki:"fat",justsolve:"FAT",wikidata:"Q190167"},tags:["dos"],license:"CC0-1.0","ks-version":.9,imports:["/common/dos_datetime"],endian:"le","bit-endian":"le"},"doc-ref":"https://download.microsoft.com/download/0/8/4/084c452b-b772-4fe5-89bb-a0cbf082286a/fatgen103.doc",seq:[{id:"boot_sector",type:"boot_sector"}],instances:{fats:{pos:"boot_sector.pos_fats",size:"boot_sector.size_fat",repeat:"expr","repeat-expr":"boot_sector.bpb.num_fats"},root_dir:{pos:"boot_sector.pos_root_dir",size:"boot_sector.size_root_dir",type:"root_directory"}},types:{boot_sector:{seq:[{id:"jmp_instruction",size:3},{id:"oem_name",type:"str",encoding:"ASCII","pad-right":32,size:8},{id:"bpb",type:"bios_param_block",doc:"Basic BIOS parameter block, present in all versions of FAT"},{id:"ebpb_fat16",type:"ext_bios_param_block_fat16",if:"not is_fat32",doc:"FAT12/16-specific extended BIOS parameter block"},{id:"ebpb_fat32",type:"ext_bios_param_block_fat32",if:"is_fat32",doc:"FAT32-specific extended BIOS parameter block"}],instances:{is_fat32:{value:"bpb.max_root_dir_rec == 0",doc:"Determines if filesystem is FAT32 (true) or FAT12/16 (false)\nby analyzing some preliminary conditions in BPB. Used to\ndetermine whether we should parse post-BPB data as\n`ext_bios_param_block_fat16` or `ext_bios_param_block_fat32`.\n"},pos_fats:{value:"bpb.bytes_per_ls * bpb.num_reserved_ls",doc:"Offset of FATs in bytes from start of filesystem"},ls_per_fat:{value:"is_fat32 ? ebpb_fat32.ls_per_fat : bpb.ls_per_fat"},size_fat:{value:"bpb.bytes_per_ls * ls_per_fat",doc:"Size of one FAT in bytes"},pos_root_dir:{value:"bpb.bytes_per_ls * (bpb.num_reserved_ls + ls_per_fat * bpb.num_fats)",doc:"Offset of root directory in bytes from start of filesystem"},ls_per_root_dir:{"-orig-id":"RootDirSectors",value:"(bpb.max_root_dir_rec * 32 + bpb.bytes_per_ls - 1) / bpb.bytes_per_ls",doc:"Size of root directory in logical sectors","doc-ref":'FAT: General Overview of On-Disk Format, section "FAT Data Structure"'},size_root_dir:{value:"ls_per_root_dir * bpb.bytes_per_ls",doc:"Size of root directory in bytes"}}},bios_param_block:{seq:[{id:"bytes_per_ls","-orig-id":"BPB_BytsPerSec",type:"u2",doc:"Bytes per logical sector"},{id:"ls_per_clus","-orig-id":"BPB_SecPerClus",type:"u1",doc:"Logical sectors per cluster"},{id:"num_reserved_ls","-orig-id":"BPB_RsvdSecCnt",type:"u2",doc:`Count of reserved logical sectors. The number of logical
sectors before the first FAT in the file system image.
`},{id:"num_fats","-orig-id":"BPB_NumFATs",type:"u1",doc:"Number of File Allocation Tables"},{id:"max_root_dir_rec","-orig-id":"BPB_RootEntCnt",type:"u2",doc:`Maximum number of FAT12 or FAT16 root directory entries. 0
for FAT32, where the root directory is stored in ordinary
data clusters.
`},{id:"total_ls_2","-orig-id":"BPB_TotSec16",type:"u2",doc:"Total logical sectors (if zero, use total_ls_4)"},{id:"media_code","-orig-id":"BPB_Media",type:"u1",doc:"Media descriptor"},{id:"ls_per_fat","-orig-id":"BPB_FATSz16",type:"u2",doc:`Logical sectors per File Allocation Table for
FAT12/FAT16. FAT32 sets this to 0 and uses the 32-bit value
at offset 0x024 instead.
`},{id:"ps_per_track","-orig-id":"BPB_SecPerTrk",type:"u2",doc:`Physical sectors per track for disks with INT 13h CHS
geometry, e.g., 15 for a "1.20 MB" (1200 KB) floppy. A zero
entry indicates that this entry is reserved, but not used.
`},{id:"num_heads","-orig-id":"BPB_NumHeads",type:"u2",doc:`Number of heads for disks with INT 13h CHS geometry,[9]
e.g., 2 for a double sided floppy.
`},{id:"num_hidden_sectors","-orig-id":"BPB_HiddSec",type:"u4",doc:`Number of hidden sectors preceding the partition that
contains this FAT volume. This field should always be zero
on media that are not partitioned. This DOS 3.0 entry is
incompatible with a similar entry at offset 0x01C in BPBs
since DOS 3.31.  It must not be used if the logical sectors
entry at offset 0x013 is zero.
`},{id:"total_ls_4","-orig-id":"BPB_TotSec32",type:"u4",doc:`Total logical sectors including hidden sectors. This DOS 3.2
entry is incompatible with a similar entry at offset 0x020
in BPBs since DOS 3.31. It must not be used if the logical
sectors entry at offset 0x013 is zero.
`}]},ext_bios_param_block_fat16:{doc:`Extended BIOS Parameter Block (DOS 4.0+, OS/2 1.0+). Used only
for FAT12 and FAT16.
`,seq:[{id:"phys_drive_num",type:"u1",doc:`Physical drive number (0x00 for (first) removable media,
0x80 for (first) fixed disk as per INT 13h).
`},{id:"reserved1",type:"u1"},{id:"ext_boot_sign",type:"u1",doc:`Should be 0x29 to indicate that an EBPB with the following 3
entries exists.
`},{id:"volume_id",size:4,doc:`Volume ID (serial number).

Typically the serial number "xxxx-xxxx" is created by a
16-bit addition of both DX values returned by INT 21h/AH=2Ah
(get system date) and INT 21h/AH=2Ch (get system time) for
the high word and another 16-bit addition of both CX values
for the low word of the serial number. Alternatively, some
DR-DOS disk utilities provide a /# option to generate a
human-readable time stamp "mmdd-hhmm" build from BCD-encoded
8-bit values for the month, day, hour and minute instead of
a serial number.
`},{id:"partition_volume_label",size:11,type:"str",encoding:"ASCII","pad-right":32},{id:"fs_type_str",size:8,type:"str",encoding:"ASCII","pad-right":32}]},ext_bios_param_block_fat32:{doc:"Extended BIOS Parameter Block for FAT32",seq:[{id:"ls_per_fat",type:"u4",doc:"Logical sectors per file allocation table (corresponds with\nthe old entry `ls_per_fat` in the DOS 2.0 BPB).\n"},{id:"has_active_fat",type:"b1",doc:`If true, then there is "active" FAT, which is designated in
\`active_fat\` attribute. If false, all FATs are mirrored as
usual.
`},{id:"reserved1",type:"b3"},{id:"active_fat_id",type:"b4",doc:"Zero-based number of active FAT, if `has_active_fat`\nattribute is true.\n"},{id:"reserved2",contents:[0]},{id:"fat_version",type:"u2"},{id:"root_dir_start_clus",type:"u4",doc:`Cluster number of root directory start, typically 2 if it
contains no bad sector. (Microsoft's FAT32 implementation
imposes an artificial limit of 65,535 entries per directory,
whilst many third-party implementations do not.)
`},{id:"ls_fs_info",type:"u2",doc:`Logical sector number of FS Information Sector, typically 1,
i.e., the second of the three FAT32 boot sectors. Values
like 0 and 0xFFFF are used by some FAT32 implementations to
designate absence of FS Information Sector.
`},{id:"boot_sectors_copy_start_ls",type:"u2",doc:`First logical sector number of a copy of the three FAT32
boot sectors, typically 6.
`},{id:"reserved3",size:12},{id:"phys_drive_num",type:"u1",doc:`Physical drive number (0x00 for (first) removable media,
0x80 for (first) fixed disk as per INT 13h).
`},{id:"reserved4",type:"u1"},{id:"ext_boot_sign",type:"u1",doc:`Should be 0x29 to indicate that an EBPB with the following 3
entries exists.
`},{id:"volume_id",size:4,doc:`Volume ID (serial number).

Typically the serial number "xxxx-xxxx" is created by a
16-bit addition of both DX values returned by INT 21h/AH=2Ah
(get system date) and INT 21h/AH=2Ch (get system time) for
the high word and another 16-bit addition of both CX values
for the low word of the serial number. Alternatively, some
DR-DOS disk utilities provide a /# option to generate a
human-readable time stamp "mmdd-hhmm" build from BCD-encoded
8-bit values for the month, day, hour and minute instead of
a serial number.
`},{id:"partition_volume_label",size:11,type:"str",encoding:"ASCII","pad-right":32},{id:"fs_type_str",size:8,type:"str",encoding:"ASCII","pad-right":32}]},root_directory:{seq:[{id:"records",type:"root_directory_rec",repeat:"expr","repeat-expr":"_root.boot_sector.bpb.max_root_dir_rec"}]},root_directory_rec:{seq:[{id:"file_name",size:11},{id:"attrs",size:1,type:"attr_flags"},{id:"reserved",size:10},{id:"last_write_time",size:4,type:"dos_datetime"},{id:"start_clus",type:"u2"},{id:"file_size",type:"u4"}],types:{attr_flags:{seq:[{id:"read_only",type:"b1"},{id:"hidden",type:"b1"},{id:"system",type:"b1"},{id:"volume_id",type:"b1"},{id:"is_directory",type:"b1"},{id:"archive",type:"b1"},{id:"reserved",type:"b2"}],instances:{long_name:{value:`read_only
and hidden
and system
and volume_id
`}}}}}}}};export{B as default,P as spec};
