import{k as f}from"./index-COA_x_BK.js";var b=Object.getOwnPropertyNames,u=(o,i)=>function(){return i||(0,o[b(o)[0]])((i={exports:{}}).exports,i),i.exports},p=u({"<stdin>"(o){(function(i,s){typeof define=="function"&&define.amd?define(["exports","kaitai-struct/KaitaiStream"],s):typeof o=="object"&&o!==null&&typeof o.nodeType!="number"?s(o,f.KaitaiStream):s(i.Zisofs||(i.Zisofs={}),i.KaitaiStream)})(typeof self<"u"?self:o,function(i,s){var _=(function(){function n(t,e,r){this._io=t,this._parent=e,this._root=r||this,this._debug={},this._read()}n.prototype._read=function(){this._debug.header={start:this._io.pos,ioOffset:this._io.byteOffset},this._raw_header=this._io.readBytes(16);var t=new s(this._raw_header);this.header=new d(t,this,this._root),this._debug.header.end=this._io.pos,this._debug.blockPointers={start:this._io.pos,ioOffset:this._io.byteOffset},this._debug.blockPointers.arr=[],this.blockPointers=[];for(var e=0;e<this.header.numBlocks+1;e++)this._debug.blockPointers.arr[e]={start:this._io.pos,ioOffset:this._io.byteOffset},this.blockPointers.push(this._io.readU4le()),this._debug.blockPointers.arr[e].end=this._io.pos;this._debug.blockPointers.end=this._io.pos};var h=n.Block=(function(){function t(e,r,a,c,l){this._io=e,this._parent=r,this._root=a,this.ofsStart=c,this.ofsEnd=l,this._debug={},this._read()}return t.prototype._read=function(){},Object.defineProperty(t.prototype,"data",{get:function(){if(this._m_data!==void 0)return this._m_data;var e=this._root._io,r=e.pos;return e.seek(this.ofsStart),this._debug._m_data={start:e.pos,ioOffset:e.byteOffset},this._m_data=e.readBytes(this.lenData),this._debug._m_data.end=e.pos,e.seek(r),this._m_data}}),Object.defineProperty(t.prototype,"lenData",{get:function(){return this._m_lenData!==void 0?this._m_lenData:(this._debug._m_lenData={},this._m_lenData=this.ofsEnd-this.ofsStart,this._m_lenData)}}),t})(),d=n.Header=(function(){function t(e,r,a){this._io=e,this._parent=r,this._root=a,this._debug={},this._read()}return t.prototype._read=function(){if(this._debug.magic={start:this._io.pos,ioOffset:this._io.byteOffset},this.magic=this._io.readBytes(8),this._debug.magic.end=this._io.pos,s.byteArrayCompare(this.magic,new Uint8Array([55,228,83,150,201,219,214,7]))!=0){var e=new s.ValidationNotEqualError(new Uint8Array([55,228,83,150,201,219,214,7]),this.magic,this._io,"/types/header/seq/0");throw this._debug.magic.validationError=e,e}if(this._debug.uncompressedSize={start:this._io.pos,ioOffset:this._io.byteOffset},this.uncompressedSize=this._io.readU4le(),this._debug.uncompressedSize.end=this._io.pos,this._debug.lenHeader={start:this._io.pos,ioOffset:this._io.byteOffset},this.lenHeader=this._io.readU1(),this._debug.lenHeader.end=this._io.pos,this.lenHeader!=4){var e=new s.ValidationNotEqualError(4,this.lenHeader,this._io,"/types/header/seq/2");throw this._debug.lenHeader.validationError=e,e}if(this._debug.blockSizeLog2={start:this._io.pos,ioOffset:this._io.byteOffset},this.blockSizeLog2=this._io.readU1(),this._debug.blockSizeLog2.end=this._io.pos,!(this.blockSizeLog2==15||this.blockSizeLog2==16||this.blockSizeLog2==17)){var e=new s.ValidationNotAnyOfError(this.blockSizeLog2,this._io,"/types/header/seq/3");throw this._debug.blockSizeLog2.validationError=e,e}if(this._debug.reserved={start:this._io.pos,ioOffset:this._io.byteOffset},this.reserved=this._io.readBytes(2),this._debug.reserved.end=this._io.pos,s.byteArrayCompare(this.reserved,new Uint8Array([0,0]))!=0){var e=new s.ValidationNotEqualError(new Uint8Array([0,0]),this.reserved,this._io,"/types/header/seq/4");throw this._debug.reserved.validationError=e,e}},Object.defineProperty(t.prototype,"blockSize",{get:function(){return this._m_blockSize!==void 0?this._m_blockSize:(this._debug._m_blockSize={},this._m_blockSize=1<<this.blockSizeLog2,this._m_blockSize)}}),Object.defineProperty(t.prototype,"numBlocks",{get:function(){return this._m_numBlocks!==void 0?this._m_numBlocks:(this._debug._m_numBlocks={},this._m_numBlocks=Math.floor(this.uncompressedSize/this.blockSize)+(s.mod(this.uncompressedSize,this.blockSize)!=0?1:0),this._m_numBlocks)}}),t})();return Object.defineProperty(n.prototype,"blocks",{get:function(){if(this._m_blocks!==void 0)return this._m_blocks;this._debug._m_blocks={start:this._io.pos,ioOffset:this._io.byteOffset},this._debug._m_blocks.arr=[],this._m_blocks=[];for(var t=0;t<this.header.numBlocks;t++)this._debug._m_blocks.arr[t]={start:this._io.pos,ioOffset:this._io.byteOffset},this._m_blocks.push(new h(this._io,this,this._root,this.blockPointers[t],this.blockPointers[t+1])),this._debug._m_blocks.arr[t].end=this._io.pos;return this._debug._m_blocks.end=this._io.pos,this._m_blocks}}),n})();i.Zisofs=_})}});const k=p(),y={id:"zisofs",title:"zisofs",ksy:{meta:{id:"zisofs",title:"zisofs",xref:{justsolve:"Zisofs",wikidata:"Q105854284"},tags:["archive","filesystem"],license:"CC0-1.0",endian:"le"},doc:`zisofs is a compression format for files on ISO9660 file system. It has
limited support across operating systems, mainly Linux kernel. Typically a
directory tree is first preprocessed by mkzftree (from the zisofs-tools
package before being turned into an ISO9660 image by mkisofs, genisoimage
or similar tool. The data is zlib compressed.

The specification here describes the structure of a file that has been
preprocessed by mkzftree, not of a full ISO9660 ziso. Data is not
decompressed, as blocks with length 0 have a special meaning. Decompression
and deconstruction of this data should be done outside of Kaitai Struct.
`,"doc-ref":"https://web.archive.org/web/20200612093441/https://dev.lovelyhq.com/libburnia/web/-/wikis/zisofs",seq:[{id:"header",size:16,type:"header"},{id:"block_pointers",type:"u4",repeat:"expr","repeat-expr":"header.num_blocks + 1",doc:"The final pointer (`block_pointers[header.num_blocks]`) indicates the end\nof the last block. Typically this is also the end of the file data.\n"}],instances:{blocks:{type:"block(block_pointers[_index], block_pointers[_index + 1])",repeat:"expr","repeat-expr":"header.num_blocks"}},types:{header:{seq:[{id:"magic",contents:[55,228,83,150,201,219,214,7]},{id:"uncompressed_size",type:"u4",doc:"Size of the original uncompressed file"},{id:"len_header",type:"u1",valid:4,doc:"header_size >> 2 (currently 4)"},{id:"block_size_log2",type:"u1",valid:{"any-of":[15,16,17]}},{id:"reserved",contents:[0,0]}],instances:{block_size:{value:"1 << block_size_log2"},num_blocks:{value:"(uncompressed_size / block_size) + (uncompressed_size % block_size != 0 ? 1 : 0)",doc:"ceil(uncompressed_size / block_size)"}}},block:{"-webide-representation":"[{ofs_start}, {ofs_end}): {len_data:dec} bytes",params:[{id:"ofs_start",type:"u4"},{id:"ofs_end",type:"u4"}],instances:{len_data:{value:"ofs_end - ofs_start"},data:{io:"_root._io",pos:"ofs_start",size:"len_data"}}}}}};export{k as default,y as spec};
