/**
 * This file was auto-generated from the KSY schema specification.
 * Do not edit this file directly. Run 'pnpm generate:schema-types' to regenerate.
 */

export type MediaWikiPageName = string;
export type IsoIdentifier = string;
export type LocIdentifier = string;
export type MimeType = string;
export type PronomIdentifier = string;
export type RfcIdentifier = number | string;
export type WikidataIdentifier = string;
export type AnyScalar = string | number | boolean | null;
/**
 * used to give a more detailed description of a user-defined type. In most languages, it will be used as a docstring compatible with tools like Javadoc, Doxygen, JSDoc, etc.
 */
export type Doc = string;
/**
 * used to provide reference to original documentation (if the ksy file is actually an implementation of some documented format).
 *
 * Contains:
 * 1. URL as text,
 * 2. arbitrary string, or
 * 3. URL as text + space + arbitrary string
 */
export type DocRef = string | string[];
/**
 * expression that provides a human-readable string representation of an object of this user-defined type for debugging purposes
 *
 * it will be used to override the standard method for converting an object to a string called `toString()` (or similar) in most target languages, `__str__()` in Python and `to_s` in Ruby; in Rust, it is the `Display` trait
 */
export type ToString = string;
export type ParamsSpec = ParamSpec[];
export type Attribute = Attribute1 & {
  /**
   * contains a string used to identify one attribute among others
   */
  id?: string;
  doc?: Doc;
  "doc-ref"?: DocRef;
  /**
   * specify fixed contents that the parser should encounter at this point. If the content of the stream doesn't match the given bytes, an error is thrown and it's meaningless to continue parsing
   */
  contents?: string | StringOrInteger[];
  /**
   * validation constraints that the actual value of the attribute must satisfy, otherwise a subclass of `ValidationFailedError` will be raised
   */
  valid?:
    | (string | number | boolean | null)
    | {
        /**
         * expression that specifies the only valid value for this attribute
         *
         * more explicit, long form of `valid: value`
         *
         * if the actual value does not satisfy this constraint, a `ValidationNotEqualError` exception will be thrown
         */
        eq: string | number | boolean | null;
        /**
         * This interface was referenced by `undefined`'s JSON-Schema definition
         * via the `patternProperty` "^-".
         */
        [k: string]: unknown;
      }
    | {
        /**
         * boolean expression that must evaluate to `true` for the attribute value to be considered valid
         *
         * actual value can be referenced via a special built-in local variable `_`
         *
         * for better declarativeness, it should only be used to enforce validation constraints that cannot be captured by any of the other dedicated `valid` subkeys (in other words, other subkeys should be preferred: for example, prefer `max: 5` to `expr: _ <= 5`)
         *
         * if the actual value does not satisfy this constraint, a `ValidationExprError` exception will be thrown
         */
        expr: string | boolean;
        /**
         * This interface was referenced by `undefined`'s JSON-Schema definition
         * via the `patternProperty` "^-".
         */
        [k: string]: unknown;
      }
    | {
        /**
         * list of expressions that specify a set of valid values for this attribute (the actual value must be equal to **any of** the values in the list)
         *
         * if the actual value does not satisfy this constraint, a `ValidationNotAnyOfError` exception will be thrown
         */
        "any-of": AnyScalar[];
        /**
         * This interface was referenced by `undefined`'s JSON-Schema definition
         * via the `patternProperty` "^-".
         */
        [k: string]: unknown;
      }
    | {
        [k: string]: unknown;
      }
    | {
        /**
         * consider only values defined in the enum as valid
         *
         * can only be used on enum attributes (i.e. those that use the `enum` key)
         *
         * if the actual integer value does not correspond to any defined member of the enum, a `ValidationNotInEnumError` exception will be thrown
         */
        "in-enum": true;
        /**
         * This interface was referenced by `undefined`'s JSON-Schema definition
         * via the `patternProperty` "^-".
         */
        [k: string]: unknown;
      };
  /**
   * defines data type for an attribute
   *
   * the type can also be user-defined in the `types` key
   *
   * one can reference a nested user-defined type by specifying a relative path to it from the current type, with a double colon as a path delimiter (e.g. `foo::bar::my_type`)
   */
  type?:
    | TypeRef
    | {
        "switch-on": AnyScalar;
        cases: {
          [k: string]: TypeRef;
        };
        /**
         * This interface was referenced by `undefined`'s JSON-Schema definition
         * via the `patternProperty` "^-".
         */
        [k: string]: unknown;
      };
  /**
   * designates repeated attribute in a structure
   *
   * | Value     | Description
   * |-
   * | `eos`     | repeat until the end of the current stream
   * | `expr`    | repeat as many times as specified in `repeat-expr`
   * | `until`   | repeat until the expression in `repeat-until` becomes **`true`**
   *
   * attribute read as array/list/sequence
   */
  repeat?: "expr" | "eos" | "until";
  /**
   * specify number of repetitions for repeated attribute
   */
  "repeat-expr"?: string | number;
  /**
   * specifies a condition to be checked **after** each parsed item, repeating while the expression is `false`
   *
   * one can use `_` in the expression, which is a special **local** variable that references the last read element
   */
  "repeat-until"?: string | boolean;
  /**
   * marks the attribute as optional (attribute is parsed only if the condition specified evaluates to `true`)
   */
  if?: string | boolean;
  /**
   * the number of bytes to read if `type` isn't defined.
   *
   * can also be an expression
   */
  size?: string | number;
  /**
   * if `true`, reads all the bytes till the end of the stream
   *
   * default is `false`
   */
  "size-eos"?: boolean;
  /**
   * specifies an algorithm to be applied to the underlying byte buffer of the attribute before parsing
   *
   * can be used only if the size is known (either `size`, `size-eos: true` or `terminator` are specified), see [Applying `process` without a size](https://doc.kaitai.io/user_guide.html#_applying_process_without_a_size) in the User Guide
   *
   * | Value | Description
   * |-
   * | `xor(key)` | <p>apply a bitwise XOR (written as `^` in most C-like languages) to every byte of the buffer using the provided `key`</p><p>**`key`** is required, and can be either <ul><li>a single byte value — will be XORed with every byte of the input stream <ul><li>make sure that the **`key`** is in range **0-255**, otherwise you may get unexpected results</li></ul></li><li>a byte array — first byte of the input will be XORed with the first byte of the key, second byte of the input with the second byte of the key, etc. <ul><li>when the end of the key is reached, it starts again from the first byte</li></ul></li></ul></p><p>_the output length remains the same as the input length_</p>
   * | `rol(n)`, `ror(n)` | <p>apply a [bitwise rotation](https://en.wikipedia.org/wiki/Bitwise_operation#bit_rotation) (also known as a [circular shift](https://en.wikipedia.org/wiki/Circular_shift)) by **`n`** bits to every byte of the buffer</p><p>`rol` = left circular shift, `ror` = right circular shift</p><p>**`n`** is required, and should be in range **0-7** for consistent results (to be safe, use `shift_amount % 8` as the **`n`** parameter, if the value of `shift_amount` itself may not fall into that range)</p>
   * | `zlib` | <p>apply a _zlib_ decompression to the input buffer, expecting it to be a full-fledged _zlib_ stream, i.e. having a regular 2-byte _zlib_ header.</p><p>typical _zlib_ header values: <ul><li>`78 01` — low compression</li><li>`78 9C` — default compression</li><li>`78 DA` — best compression</li></ul></p>
   * | <p>`{my_custom_processor}(a, b, ...)`</p><p><i>(`{my_custom_processor}` is an arbitrary name matching `[a-z][a-z0-9_.]*`)</i></p> | <p>use a custom processing routine, which you implement in imperative code in the target language</p><p>the generated code will use the class name `{my_custom_processor}` using the naming convention of the target language (in most languages `MyCustomProcessor`, but e.g. `my_custom_processor_t` in C++: check the generated code)</p><p>the processing class **must** define the method `public byte[] decode(byte[] src)` and should implement the interface `CustomDecoder` (available in [C++](https://github.com/kaitai-io/kaitai_struct_cpp_stl_runtime/blob/d020781b96ea1e2fe7e0ecf47ff3ae3c829ccd31/kaitai/custom_decoder.h#L8-L12), [C#](https://github.com/kaitai-io/kaitai_struct_csharp_runtime/blob/1b66a9a85f39c52728893400a23504844cc78e34/KaitaiStruct.cs#L24-L37) and [Java](https://github.com/kaitai-io/kaitai_struct_java_runtime/blob/c342c6e836ddba03c9ec33a59034e209bb04a976/src/main/java/io/kaitai/struct/CustomDecoder.java#L26-L39))</p><p>you can pass any parameters `(a, b, ...)` to your `{my_custom_processor}` class constructor (**omit** the `()` brackets for parameter-less invocation)</p><p></p><p>one can reference a class in a different namespace/package like `com.example.my_rle(5, 3)`</p><p><i>see [Custom processing routines](https://doc.kaitai.io/user_guide.html#custom-process) in the User Guide for more info</i></p>
   */
  process?: string;
  /**
   * name of existing enum field data type becomes given enum
   */
  enum?: string;
  encoding?: CharacterEncoding;
  /**
   * specify a byte which is the string or byte array padded with after the end up to the total size
   *
   * can be used only with `size` or `size-eos: true` (when the size is fixed)
   *
   * when `terminator`:
   *  - isn't specified, then the `pad-right` controls where the string ends (basically acts like a terminator)
   *  - is specified, padding comes after the terminator, not before. The value is terminated immediately after the terminator occurs, so the `pad-right` has no effect on parsing and is only relevant for serialization
   */
  "pad-right"?: number;
  /**
   * string or byte array reading will stop when it encounters this byte
   *
   * cannot be used with `type: strz` (which already implies `terminator: 0` - null-terminated string)
   */
  terminator?: number;
  /**
   * specify if terminator byte should be "consumed" when reading
   *
   * if true: the stream pointer will point to the byte after the terminator byte
   *
   * if false: the stream pointer will point to the terminator byte itself
   *
   * default is true
   */
  consume?: boolean;
  /**
   * specifies if terminator byte should be considered part of the string read and thus be appended to it
   *
   * default is false
   */
  include?: boolean;
  /**
   * allows the compiler to ignore the lack of a terminator if eos-error is disabled, string reading will stop at either:
   *
   * 1. terminator being encountered
   *
   * 2. end of stream is reached
   *
   * default is `true`
   */
  "eos-error"?: boolean;
  /**
   * specifies position at which the value should be parsed
   */
  pos?: string | number;
  /**
   * specifies an IO stream from which a value should be parsed
   */
  io?: string;
  /**
   * overrides any reading & parsing. Instead, just calculates function specified in value and returns the result as this instance. Has many purposes
   */
  value?: {
    [k: string]: unknown;
  };
  /**
   * This interface was referenced by `undefined`'s JSON-Schema definition
   * via the `patternProperty` "^-".
   */
  [k: string]: unknown;
};
/**
 * This interface was referenced by `InstancesSpec`'s JSON-Schema definition
 * via the `patternProperty` "^[a-z][a-z0-9_]*$".
 *
 * This interface was referenced by `InstancesSpec1`'s JSON-Schema definition
 * via the `patternProperty` "^[a-z][a-z0-9_]*$".
 */
export type Attribute1 = {
  [k: string]: unknown;
};
export type StringOrInteger = string | number;
/**
 * This interface was referenced by `undefined`'s JSON-Schema definition
 * via the `patternProperty` "^.*$".
 */
export type TypeRef =
  | string
  | (
      | "u1"
      | "u2"
      | "u2le"
      | "u2be"
      | "u4"
      | "u4le"
      | "u4be"
      | "u8"
      | "u8le"
      | "u8be"
      | "s1"
      | "s2"
      | "s2le"
      | "s2be"
      | "s4"
      | "s4le"
      | "s4be"
      | "s8"
      | "s8le"
      | "s8be"
      | "f4"
      | "f4be"
      | "f4le"
      | "f8"
      | "f8be"
      | "f8le"
      | "str"
      | "strz"
    );
/**
 * canonical names of character encodings supported by Kaitai Struct
 *
 * in addition to these canonical names, the compiler (since version 0.11) also recognizes their popular aliases, but issues a warning for them
 */
export type CharacterEncoding =
  | "ASCII"
  | "UTF-8"
  | "UTF-16BE"
  | "UTF-16LE"
  | "UTF-32BE"
  | "UTF-32LE"
  | "ISO-8859-1"
  | "ISO-8859-2"
  | "ISO-8859-3"
  | "ISO-8859-4"
  | "ISO-8859-5"
  | "ISO-8859-6"
  | "ISO-8859-7"
  | "ISO-8859-8"
  | "ISO-8859-9"
  | "ISO-8859-10"
  | "ISO-8859-11"
  | "ISO-8859-13"
  | "ISO-8859-14"
  | "ISO-8859-15"
  | "ISO-8859-16"
  | "windows-1250"
  | "windows-1251"
  | "windows-1252"
  | "windows-1253"
  | "windows-1254"
  | "windows-1255"
  | "windows-1256"
  | "windows-1257"
  | "windows-1258"
  | "IBM437"
  | "IBM866"
  | "Shift_JIS"
  | "Big5"
  | "EUC-KR";
/**
 * identifier for a primary structure described in top-level map
 */
export type Attributes = Attribute[];
export type Attributes1 = Attribute1[];
/**
 * This interface was referenced by `EnumSpec`'s JSON-Schema definition
 * via the `patternProperty` "^.*$".
 */
export type EnumValueSpec =
  | Identifier
  | {
      id: Identifier;
      doc?: Doc;
      "doc-ref"?: DocRef;
      "-orig-id"?: string | string[];
      /**
       * This interface was referenced by `undefined`'s JSON-Schema definition
       * via the `patternProperty` "^-".
       */
      [k: string]: unknown;
    };
export type Identifier = string | boolean;

/**
 * the schema for ksy files
 */
export interface KsySchema {
  meta?: MetaSpec;
  doc?: Doc;
  "doc-ref"?: DocRef;
  "to-string"?: ToString;
  params?: ParamsSpec;
  seq?: Attributes;
  instances?: InstancesSpec;
  types?: TypesSpec;
  enums?: EnumsSpec1;
  /**
   * This interface was referenced by `KsySchema`'s JSON-Schema definition
   * via the `patternProperty` "^-".
   */
  [k: string]: unknown;
}
export interface MetaSpec {
  /**
   * unique string that identifies this format
   *
   * should be identical to the file name without the `.ksy` extension (e.g. `microsoft_pe` for `microsoft_pe.ksy`)
   *
   * used to derive the name of the top-level type when generating parsers
   *
   * required at the top level, shouldn't be used at nested levels
   */
  id: string | boolean;
  /**
   * brief name of the format
   */
  title?: string;
  /**
   * applications that use this format and are typically associated with it
   */
  application?: string | string[];
  /**
   * file extensions typically used for this format, without the leading dot and in lowercase letters
   *
   * should be sorted from most popular to least popular
   */
  "file-extension"?: string | string[];
  xref?: {
    /**
     * article name at [Forensics Wiki](https://forensics.wiki/), which is a CC-BY-SA-licensed wiki with information on digital forensics, file formats and tools
     *
     * full link name could be generated as `https://forensics.wiki/` + this value + `/`
     */
    forensicswiki?: MediaWikiPageName | MediaWikiPageName[];
    /**
     * ISO/IEC standard number, reference to a standard accepted and published by [ISO](https://www.iso.org/) (International Organization for Standardization).
     *
     * ISO standards typically have clear designations like "ISO/IEC 15948:2004", so value should be citing everything except for "ISO/IEC", i.e. `15948:2004`
     */
    iso?: IsoIdentifier | IsoIdentifier[];
    /**
     * article name at ["Just Solve the File Format Problem" wiki](http://fileformats.archiveteam.org/wiki/Main_Page), a wiki that collects information on many file formats
     *
     * full link name could be generated as `http://fileformats.archiveteam.org/wiki/` + this value
     */
    justsolve?: MediaWikiPageName | MediaWikiPageName[];
    /**
     * identifier in [Digital Formats](https://www.loc.gov/preservation/digital/formats/fdd/browse_list.shtml) database of [US Library of Congress](https://www.loc.gov/)
     *
     * value typically looks like `fddXXXXXX`, where `XXXXXX` is a 6-digit identifier
     */
    loc?: LocIdentifier | LocIdentifier[];
    /**
     * MIME type (IANA media type), a string typically used in various Internet protocols to specify format of binary payload
     *
     * there is a [central registry of media types](https://www.iana.org/assignments/media-types/media-types.xhtml) managed by IANA
     *
     * value must specify full MIME type (both parts), e.g. `image/png`
     */
    mime?: MimeType | MimeType[];
    /**
     * format identifier in [PRONOM Technical Registry](https://www.nationalarchives.gov.uk/PRONOM/BasicSearch/proBasicSearch.aspx?status=new) of [UK National Archives](https://www.nationalarchives.gov.uk/), which is a massive file formats database that catalogues many file formats for digital preservation purposes
     */
    pronom?: PronomIdentifier | PronomIdentifier[];
    /**
     * reference to [RFC](https://en.wikipedia.org/wiki/Request_for_Comments), "Request for Comments" documents maintained by ISOC (Internet Society)
     *
     * RFCs are typically treated as global, Internet-wide standards, and, for example, many networking / interoperability protocols are specified in RFCs
     *
     * value should be just raw RFC number, without any prefixes, e.g. `1234`
     */
    rfc?: RfcIdentifier | RfcIdentifier[];
    /**
     * item identifier at [Wikidata](https://www.wikidata.org/wiki/Wikidata:Main_Page), a global knowledge base
     *
     * value typically follows `Qxxx` pattern, where `xxx` is a number generated by [Wikidata](https://www.wikidata.org/wiki/Wikidata:Main_Page), e.g. `Q535473`
     */
    wikidata?: WikidataIdentifier | WikidataIdentifier[];
    /**
     * This interface was referenced by `undefined`'s JSON-Schema definition
     * via the `patternProperty` "^.*$".
     */
    [k: string]: AnyScalar | AnyScalar[];
  };
  /**
   * list of tags (categories/keywords) that can be assigned to the format
   *
   * used in the [format gallery](https://github.com/kaitai-io/kaitai_struct_formats) to display formats at https://formats.kaitai.io/ also in categories other than the main one, which corresponds to the directory where the `.ksy` file is located
   *
   * should match the directory names in https://github.com/kaitai-io/kaitai_struct_formats
   *
   * should be written in `lower_snake_case` and sorted in alphabetical order
   */
  tags?: string[];
  /**
   * license under which the KSY file is released
   *
   * required for all KSY specifications in the [format gallery](https://github.com/kaitai-io/kaitai_struct_formats) (otherwise optional, but [highly recommended](https://choosealicense.com/no-permission/))
   *
   * must be a valid [SPDX expression](https://spdx.github.io/spdx-spec/v3.0.1/annexes/spdx-license-expressions/) (however, a single license identifier from [this list](https://spdx.org/licenses/) is usually enough)
   *
   * to clarify, this is not a license of the original format description, but a license of the particular KSY implementation - if you're writing one, you can choose any open source license you want, regardless of what resources you use (as long as you only reproduce the idea and you don't copy long excerpts); we recommend [`CC0-1.0`](https://spdx.org/licenses/CC0-1.0.html) or [`MIT`](https://spdx.org/licenses/MIT.html)
   *
   * generated files from a KSY spec retain the same license as the original KSY
   */
  license?: string;
  /**
   * minimum Kaitai Struct compiler (KSC) version required to compile this .ksy file (older versions will refuse to compile and inform the user that they need at least the specified version)
   *
   * only versions 0.6 or higher are accepted (KSC 0.6 was the first to support `ks-version`, so there is no point in entering any lower version)
   *
   * the value must be sometimes enclosed in quotes to ensure correct interpretation, for example `ks-version: '0.10'` (without the quotes it is parsed as a float in YAML and gets interpreted as 0.1, which will be rejected)
   */
  "ks-version"?: string | number;
  /**
   * advise the Kaitai Struct Compiler (KSC) to use debug mode
   */
  "ks-debug"?: boolean;
  /**
   * advise the Kaitai Struct Compiler (KSC) to ignore missing types in the .ksy file, and assume that these types are already provided externally by the environment the classes are generated for
   */
  "ks-opaque-types"?: boolean;
  /**
   * list of relative or absolute paths to another `.ksy` files to import (**without** the `.ksy` extension)
   *
   * the top-level type of the imported file will be accessible in the current spec under the name specified in the top-level `/meta/id` of the imported file
   */
  imports?: string | string[];
  /**
   * default character encoding for string fields (of type `str` or `strz`) in the current type and its subtypes
   */
  encoding?:
    | "ASCII"
    | "UTF-8"
    | "UTF-16BE"
    | "UTF-16LE"
    | "UTF-32BE"
    | "UTF-32LE"
    | "ISO-8859-1"
    | "ISO-8859-2"
    | "ISO-8859-3"
    | "ISO-8859-4"
    | "ISO-8859-5"
    | "ISO-8859-6"
    | "ISO-8859-7"
    | "ISO-8859-8"
    | "ISO-8859-9"
    | "ISO-8859-10"
    | "ISO-8859-11"
    | "ISO-8859-13"
    | "ISO-8859-14"
    | "ISO-8859-15"
    | "ISO-8859-16"
    | "windows-1250"
    | "windows-1251"
    | "windows-1252"
    | "windows-1253"
    | "windows-1254"
    | "windows-1255"
    | "windows-1256"
    | "windows-1257"
    | "windows-1258"
    | "IBM437"
    | "IBM866"
    | "Shift_JIS"
    | "Big5"
    | "EUC-KR";
  /**
   * default endianness (byte order) of built-in multibyte numeric types, i.e. integers (`sX` and `uX`, where `X` is 2, 4 or 8) and floating-point numbers (`fX`, where `X` is 4 or 8)
   *
   * applies to the current type and its subtypes
   *
   * this key is required if you use any `sX`, `uX` or `fX` types (other than `s1` and `u1`) without an explicit `le` or `be` suffix (as in `u2be` or `f4le`)
   */
  endian?:
    | ("le" | "be")
    | {
        "switch-on": AnyScalar;
        cases: {
          /**
           * This interface was referenced by `undefined`'s JSON-Schema definition
           * via the `patternProperty` "^.*$".
           */
          [k: string]: "le" | "be";
        };
        /**
         * This interface was referenced by `undefined`'s JSON-Schema definition
         * via the `patternProperty` "^-".
         */
        [k: string]: unknown;
      };
  /**
   * default parsing direction (*bit endianness*) of bit-sized integers (built-in `bX` types)
   *
   * big-endian (`be`) order is default, but it is recommended to specify it explicitly
   *
   * can only have the literal value `le` or `be` (runtime switching [as with the `endian` key](https://doc.kaitai.io/user_guide.html#calc-endian) is not supported)
   *
   * for more information, see https://doc.kaitai.io/user_guide.html#_bit_sized_integers
   */
  "bit-endian"?: "le" | "be";
  /**
   * This interface was referenced by `MetaSpec`'s JSON-Schema definition
   * via the `patternProperty` "^-".
   */
  [k: string]: unknown;
}
export interface ParamSpec {
  id: string & {
    [k: string]: unknown;
  };
  /**
   * specifies "pure" type of the parameter, without any serialization details (like endianness, sizes, encodings)
   *
   * | Value                  | Description
   * |-
   * | `u1`, `u2`, `u4`, `u8` | unsigned integer
   * | `s1`, `s2`, `s4`, `s8` | signed integer
   * | `bX`                   | bit-sized integer (if `X` != 1)
   * | `f4`, `f8`             | floating point number
   * | `type` key missing<br>or `bytes` | byte array
   * | `str`                  | string
   * | `bool` (or `b1`)       | boolean
   * | `struct`               | arbitrary KaitaiStruct-compatible user type
   * | `io`                   | KaitaiStream-compatible IO stream
   * | `any`                  | allow any type (if target language supports that)
   * | other identifier       | user-defined type, without parameters<br>a nested type can be referenced with double colon (e.g. `type: 'foo::bar'`)
   *
   * one can specify arrays by appending `[]` after the type identifier (e.g. `type: u2[]`, `type: 'foo::bar[]'`, `type: struct[]` etc.)
   */
  type?: string;
  doc?: Doc;
  "doc-ref"?: DocRef;
  /**
   * path to an enum type (defined in the `enums` map), which will become the type of the parameter
   *
   * only integer-based enums are supported, so `type` must be an integer type (`type: uX`, `type: sX` or `type: bX`) for this property to work
   *
   * you can use `enum` with `type: b1` as well: `b1` means a 1-bit **integer** (0 or 1) when used with `enum` (**not** a boolean)
   *
   * one can reference an enum type of a subtype by specifying a relative path to it from the current type, with a double colon as a path delimiter (e.g. `foo::bar::my_enum`)
   */
  enum?: string;
  /**
   * This interface was referenced by `ParamSpec`'s JSON-Schema definition
   * via the `patternProperty` "^-".
   */
  [k: string]: unknown;
}
/**
 * Purpose: description of data that lies outside of normal sequential parsing flow (for example, that requires seeking somewhere in the file) or just needs to be loaded only by special request
 *
 * Influences: would be translated into distinct methods (that read desired data on demand) in current class
 */
export interface InstancesSpec {
  [k: string]: Attribute1;
}
/**
 * maps of strings to user-defined types
 *
 * declares types for substructures that can be referenced in the attributes of seq or instances element
 *
 * would be directly translated into classes
 */
export interface TypesSpec {
  [k: string]: TypeSpec;
}
/**
 * This interface was referenced by `TypesSpec`'s JSON-Schema definition
 * via the `patternProperty` "^[a-z][a-z0-9_]*$".
 */
export interface TypeSpec {
  meta?: MetaSpec1;
  doc?: Doc;
  "doc-ref"?: DocRef;
  "to-string"?: ToString;
  params?: ParamsSpec;
  seq?: Attributes1;
  instances?: InstancesSpec1;
  types?: TypesSpec1;
  enums?: EnumsSpec;
  /**
   * This interface was referenced by `TypeSpec`'s JSON-Schema definition
   * via the `patternProperty` "^-".
   */
  [k: string]: unknown;
}
export interface MetaSpec1 {
  /**
   * unique string that identifies this format
   *
   * should be identical to the file name without the `.ksy` extension (e.g. `microsoft_pe` for `microsoft_pe.ksy`)
   *
   * used to derive the name of the top-level type when generating parsers
   *
   * required at the top level, shouldn't be used at nested levels
   */
  id?: string | boolean;
  /**
   * brief name of the format
   */
  title?: string;
  /**
   * applications that use this format and are typically associated with it
   */
  application?: string | string[];
  /**
   * file extensions typically used for this format, without the leading dot and in lowercase letters
   *
   * should be sorted from most popular to least popular
   */
  "file-extension"?: string | string[];
  xref?: {
    /**
     * article name at [Forensics Wiki](https://forensics.wiki/), which is a CC-BY-SA-licensed wiki with information on digital forensics, file formats and tools
     *
     * full link name could be generated as `https://forensics.wiki/` + this value + `/`
     */
    forensicswiki?: MediaWikiPageName | MediaWikiPageName[];
    /**
     * ISO/IEC standard number, reference to a standard accepted and published by [ISO](https://www.iso.org/) (International Organization for Standardization).
     *
     * ISO standards typically have clear designations like "ISO/IEC 15948:2004", so value should be citing everything except for "ISO/IEC", i.e. `15948:2004`
     */
    iso?: IsoIdentifier | IsoIdentifier[];
    /**
     * article name at ["Just Solve the File Format Problem" wiki](http://fileformats.archiveteam.org/wiki/Main_Page), a wiki that collects information on many file formats
     *
     * full link name could be generated as `http://fileformats.archiveteam.org/wiki/` + this value
     */
    justsolve?: MediaWikiPageName | MediaWikiPageName[];
    /**
     * identifier in [Digital Formats](https://www.loc.gov/preservation/digital/formats/fdd/browse_list.shtml) database of [US Library of Congress](https://www.loc.gov/)
     *
     * value typically looks like `fddXXXXXX`, where `XXXXXX` is a 6-digit identifier
     */
    loc?: LocIdentifier | LocIdentifier[];
    /**
     * MIME type (IANA media type), a string typically used in various Internet protocols to specify format of binary payload
     *
     * there is a [central registry of media types](https://www.iana.org/assignments/media-types/media-types.xhtml) managed by IANA
     *
     * value must specify full MIME type (both parts), e.g. `image/png`
     */
    mime?: MimeType | MimeType[];
    /**
     * format identifier in [PRONOM Technical Registry](https://www.nationalarchives.gov.uk/PRONOM/BasicSearch/proBasicSearch.aspx?status=new) of [UK National Archives](https://www.nationalarchives.gov.uk/), which is a massive file formats database that catalogues many file formats for digital preservation purposes
     */
    pronom?: PronomIdentifier | PronomIdentifier[];
    /**
     * reference to [RFC](https://en.wikipedia.org/wiki/Request_for_Comments), "Request for Comments" documents maintained by ISOC (Internet Society)
     *
     * RFCs are typically treated as global, Internet-wide standards, and, for example, many networking / interoperability protocols are specified in RFCs
     *
     * value should be just raw RFC number, without any prefixes, e.g. `1234`
     */
    rfc?: RfcIdentifier | RfcIdentifier[];
    /**
     * item identifier at [Wikidata](https://www.wikidata.org/wiki/Wikidata:Main_Page), a global knowledge base
     *
     * value typically follows `Qxxx` pattern, where `xxx` is a number generated by [Wikidata](https://www.wikidata.org/wiki/Wikidata:Main_Page), e.g. `Q535473`
     */
    wikidata?: WikidataIdentifier | WikidataIdentifier[];
    /**
     * This interface was referenced by `undefined`'s JSON-Schema definition
     * via the `patternProperty` "^.*$".
     */
    [k: string]: AnyScalar | AnyScalar[];
  };
  /**
   * list of tags (categories/keywords) that can be assigned to the format
   *
   * used in the [format gallery](https://github.com/kaitai-io/kaitai_struct_formats) to display formats at https://formats.kaitai.io/ also in categories other than the main one, which corresponds to the directory where the `.ksy` file is located
   *
   * should match the directory names in https://github.com/kaitai-io/kaitai_struct_formats
   *
   * should be written in `lower_snake_case` and sorted in alphabetical order
   */
  tags?: string[];
  /**
   * license under which the KSY file is released
   *
   * required for all KSY specifications in the [format gallery](https://github.com/kaitai-io/kaitai_struct_formats) (otherwise optional, but [highly recommended](https://choosealicense.com/no-permission/))
   *
   * must be a valid [SPDX expression](https://spdx.github.io/spdx-spec/v3.0.1/annexes/spdx-license-expressions/) (however, a single license identifier from [this list](https://spdx.org/licenses/) is usually enough)
   *
   * to clarify, this is not a license of the original format description, but a license of the particular KSY implementation - if you're writing one, you can choose any open source license you want, regardless of what resources you use (as long as you only reproduce the idea and you don't copy long excerpts); we recommend [`CC0-1.0`](https://spdx.org/licenses/CC0-1.0.html) or [`MIT`](https://spdx.org/licenses/MIT.html)
   *
   * generated files from a KSY spec retain the same license as the original KSY
   */
  license?: string;
  /**
   * minimum Kaitai Struct compiler (KSC) version required to compile this .ksy file (older versions will refuse to compile and inform the user that they need at least the specified version)
   *
   * only versions 0.6 or higher are accepted (KSC 0.6 was the first to support `ks-version`, so there is no point in entering any lower version)
   *
   * the value must be sometimes enclosed in quotes to ensure correct interpretation, for example `ks-version: '0.10'` (without the quotes it is parsed as a float in YAML and gets interpreted as 0.1, which will be rejected)
   */
  "ks-version"?: string | number;
  /**
   * advise the Kaitai Struct Compiler (KSC) to use debug mode
   */
  "ks-debug"?: boolean;
  /**
   * advise the Kaitai Struct Compiler (KSC) to ignore missing types in the .ksy file, and assume that these types are already provided externally by the environment the classes are generated for
   */
  "ks-opaque-types"?: boolean;
  /**
   * list of relative or absolute paths to another `.ksy` files to import (**without** the `.ksy` extension)
   *
   * the top-level type of the imported file will be accessible in the current spec under the name specified in the top-level `/meta/id` of the imported file
   */
  imports?: string | string[];
  /**
   * default character encoding for string fields (of type `str` or `strz`) in the current type and its subtypes
   */
  encoding?:
    | "ASCII"
    | "UTF-8"
    | "UTF-16BE"
    | "UTF-16LE"
    | "UTF-32BE"
    | "UTF-32LE"
    | "ISO-8859-1"
    | "ISO-8859-2"
    | "ISO-8859-3"
    | "ISO-8859-4"
    | "ISO-8859-5"
    | "ISO-8859-6"
    | "ISO-8859-7"
    | "ISO-8859-8"
    | "ISO-8859-9"
    | "ISO-8859-10"
    | "ISO-8859-11"
    | "ISO-8859-13"
    | "ISO-8859-14"
    | "ISO-8859-15"
    | "ISO-8859-16"
    | "windows-1250"
    | "windows-1251"
    | "windows-1252"
    | "windows-1253"
    | "windows-1254"
    | "windows-1255"
    | "windows-1256"
    | "windows-1257"
    | "windows-1258"
    | "IBM437"
    | "IBM866"
    | "Shift_JIS"
    | "Big5"
    | "EUC-KR";
  /**
   * default endianness (byte order) of built-in multibyte numeric types, i.e. integers (`sX` and `uX`, where `X` is 2, 4 or 8) and floating-point numbers (`fX`, where `X` is 4 or 8)
   *
   * applies to the current type and its subtypes
   *
   * this key is required if you use any `sX`, `uX` or `fX` types (other than `s1` and `u1`) without an explicit `le` or `be` suffix (as in `u2be` or `f4le`)
   */
  endian?:
    | ("le" | "be")
    | {
        "switch-on": AnyScalar;
        cases: {
          /**
           * This interface was referenced by `undefined`'s JSON-Schema definition
           * via the `patternProperty` "^.*$".
           */
          [k: string]: "le" | "be";
        };
        /**
         * This interface was referenced by `undefined`'s JSON-Schema definition
         * via the `patternProperty` "^-".
         */
        [k: string]: unknown;
      };
  /**
   * default parsing direction (*bit endianness*) of bit-sized integers (built-in `bX` types)
   *
   * big-endian (`be`) order is default, but it is recommended to specify it explicitly
   *
   * can only have the literal value `le` or `be` (runtime switching [as with the `endian` key](https://doc.kaitai.io/user_guide.html#calc-endian) is not supported)
   *
   * for more information, see https://doc.kaitai.io/user_guide.html#_bit_sized_integers
   */
  "bit-endian"?: "le" | "be";
  /**
   * This interface was referenced by `MetaSpec1`'s JSON-Schema definition
   * via the `patternProperty` "^-".
   */
  [k: string]: unknown;
}
export interface InstancesSpec1 {
  [k: string]: Attribute1;
}
export interface TypesSpec1 {
  [k: string]: TypeSpec;
}
export interface EnumsSpec {
  [k: string]: EnumSpec;
}
/**
 * This interface was referenced by `EnumsSpec`'s JSON-Schema definition
 * via the `patternProperty` "^[a-z][a-z0-9_]*$".
 *
 * This interface was referenced by `EnumsSpec1`'s JSON-Schema definition
 * via the `patternProperty` "^[a-z][a-z0-9_]*$".
 */
export interface EnumSpec {
  [k: string]: EnumValueSpec;
}
/**
 * allows for the setup of named enums, mappings of integer constants to symbolic names. Can be used with integer attributes using the enum key.
 *
 * would be represented as enum-like construct (or closest equivalent, if target language doesn't support enums), nested or namespaced in current type/class
 */
export interface EnumsSpec1 {
  [k: string]: EnumSpec;
}
